//=========================================================================
//
//  This file was generated by Mouse 1.5 at 2012-09-06 11:09:55 GMT
//  from grammar
//    '/Users/vvakame/Dropbox/work/jsx-plugin-for-eclipse/jsx-peg-syntax/sr
//    c/main/peg/JSX.peg'.
//
//=========================================================================

package net.vvakame.jsx.peg;

import mouse.runtime.Source;

public class JsxParser extends mouse.runtime.ParserMemo
{
  final JsxSemantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public JsxParser()
    {
      sem = new JsxSemantics();
      sem.rule = this;
      super.sem = sem;
      caches = cacheList;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      if (programFile()) return true;
      return failure();
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public JsxSemantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  programFile = spacing importStatement* classDefinition* !_
  //    {programFile} ;
  //=====================================================================
  private boolean programFile()
    {
      if (saved(programFile)) return reuse();
      spacing();
      while (importStatement());
      while (classDefinition());
      if (!aheadNot()) return reject();
      sem.programFile();
      return accept();
    }
  
  //=====================================================================
  //  importStatement = IMPORT (ident (COMMA ident)* FROM)? string (INTO
  //    ident)? SEMI {importStatement} ;
  //=====================================================================
  private boolean importStatement()
    {
      if (saved(importStatement)) return reuse();
      if (!IMPORT()) return reject();
      importStatement_0();
      if (!string()) return reject();
      importStatement_1();
      if (!SEMI()) return reject();
      sem.importStatement();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  importStatement_0 = ident (COMMA ident)* FROM
  //-------------------------------------------------------------------
  private boolean importStatement_0()
    {
      if (savedInner(importStatement_0)) return reuseInner();
      if (!ident()) return rejectInner();
      while (importStatement_2());
      if (!FROM()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  importStatement_1 = INTO ident
  //-------------------------------------------------------------------
  private boolean importStatement_1()
    {
      if (savedInner(importStatement_1)) return reuseInner();
      if (!INTO()) return rejectInner();
      if (!ident()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  importStatement_2 = COMMA ident
  //-------------------------------------------------------------------
  private boolean importStatement_2()
    {
      if (savedInner(importStatement_2)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!ident()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  classDefinition = oClassModifiers* (oClassDef / oInterfaceDef /
  //    oMixinDef) spacing ;
  //=====================================================================
  private boolean classDefinition()
    {
      if (saved(classDefinition)) return reuse();
      while (oClassModifiers());
      if (!oClassDef()
       && !oInterfaceDef()
       && !oMixinDef()
         ) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  oClassModifiers = ABSTRACT / FINAL / NATIVE / BLTCONFAKE ;
  //=====================================================================
  private boolean oClassModifiers()
    {
      if (saved(oClassModifiers)) return reuse();
      if (ABSTRACT()) return accept();
      if (FINAL()) return accept();
      if (NATIVE()) return accept();
      if (BLTCONFAKE()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  oClassDef = CLASS ident formalTypeArguments? (EXTENDS
  //    objectTypeDeclaration)? (IMPLEMENTS objectTypeDeclaration (COMMA
  //    objectTypeDeclaration)*)? LWING memberDefinition* RWING ;
  //=====================================================================
  private boolean oClassDef()
    {
      if (saved(oClassDef)) return reuse();
      if (!CLASS()) return reject();
      if (!ident()) return reject();
      formalTypeArguments();
      oClassDef_0();
      oClassDef_1();
      if (!LWING()) return reject();
      while (memberDefinition());
      if (!RWING()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  oClassDef_0 = EXTENDS objectTypeDeclaration
  //-------------------------------------------------------------------
  private boolean oClassDef_0()
    {
      if (savedInner(oClassDef_0)) return reuseInner();
      if (!EXTENDS()) return rejectInner();
      objectTypeDeclaration();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  oClassDef_1 = IMPLEMENTS objectTypeDeclaration (COMMA
  //    objectTypeDeclaration)*
  //-------------------------------------------------------------------
  private boolean oClassDef_1()
    {
      if (savedInner(oClassDef_1)) return reuseInner();
      if (!IMPLEMENTS()) return rejectInner();
      objectTypeDeclaration();
      while (oClassDef_2());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  oClassDef_2 = COMMA objectTypeDeclaration
  //-------------------------------------------------------------------
  private boolean oClassDef_2()
    {
      if (savedInner(oClassDef_2)) return reuseInner();
      if (!COMMA()) return rejectInner();
      objectTypeDeclaration();
      return acceptInner();
    }
  
  //=====================================================================
  //  oInterfaceDef = INTERFACE ident formalTypeArguments? (IMPLEMENTS
  //    objectTypeDeclaration (COMMA objectTypeDeclaration)*)? LWING
  //    memberDefinition* RWING ;
  //=====================================================================
  private boolean oInterfaceDef()
    {
      if (saved(oInterfaceDef)) return reuse();
      if (!INTERFACE()) return reject();
      if (!ident()) return reject();
      formalTypeArguments();
      oClassDef_1();
      if (!LWING()) return reject();
      while (memberDefinition());
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  oMixinDef = MIXIN ident formalTypeArguments? LWING
  //    memberDefinition* RWING ;
  //=====================================================================
  private boolean oMixinDef()
    {
      if (saved(oMixinDef)) return reuse();
      if (!MIXIN()) return reject();
      if (!ident()) return reject();
      formalTypeArguments();
      if (!LWING()) return reject();
      while (memberDefinition());
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  memberDefinition = oMemberDefinitionModifiers* CONST ident (COLON
  //    typeDeclaration)? (EQ assignExpr)? SEMI /
  //    oMemberDefinitionModifiers* FUNCTION functionDefinition /
  //    oMemberDefinitionModifiers* VAR ident (COLON typeDeclaration)?
  //    (EQ assignExpr)? SEMI ;
  //=====================================================================
  private boolean memberDefinition()
    {
      if (saved(memberDefinition)) return reuse();
      if (memberDefinition_0()) return accept();
      if (memberDefinition_1()) return accept();
      if (memberDefinition_2()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  memberDefinition_0 = oMemberDefinitionModifiers* CONST ident
  //    (COLON typeDeclaration)? (EQ assignExpr)? SEMI
  //-------------------------------------------------------------------
  private boolean memberDefinition_0()
    {
      if (savedInner(memberDefinition_0)) return reuseInner();
      while (oMemberDefinitionModifiers());
      if (!CONST()) return rejectInner();
      if (!ident()) return rejectInner();
      memberDefinition_3();
      memberDefinition_4();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  memberDefinition_1 = oMemberDefinitionModifiers* FUNCTION
  //    functionDefinition
  //-------------------------------------------------------------------
  private boolean memberDefinition_1()
    {
      if (savedInner(memberDefinition_1)) return reuseInner();
      while (oMemberDefinitionModifiers());
      if (!FUNCTION()) return rejectInner();
      if (!functionDefinition()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  memberDefinition_2 = oMemberDefinitionModifiers* VAR ident (COLON
  //    typeDeclaration)? (EQ assignExpr)? SEMI
  //-------------------------------------------------------------------
  private boolean memberDefinition_2()
    {
      if (savedInner(memberDefinition_2)) return reuseInner();
      while (oMemberDefinitionModifiers());
      if (!VAR()) return rejectInner();
      if (!ident()) return rejectInner();
      memberDefinition_3();
      memberDefinition_4();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  memberDefinition_3 = COLON typeDeclaration
  //-------------------------------------------------------------------
  private boolean memberDefinition_3()
    {
      if (savedInner(memberDefinition_3)) return reuseInner();
      if (!COLON()) return rejectInner();
      typeDeclaration();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  memberDefinition_4 = EQ assignExpr
  //-------------------------------------------------------------------
  private boolean memberDefinition_4()
    {
      if (savedInner(memberDefinition_4)) return reuseInner();
      if (!EQ()) return rejectInner();
      if (!assignExpr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  oMemberDefinitionModifiers = STATIC / ABSTRACT / OVERRIDE / FINAL /
  //    NATIVE / BLTCONREADONLY / INLINE / BLTCONPURE ;
  //=====================================================================
  private boolean oMemberDefinitionModifiers()
    {
      if (saved(oMemberDefinitionModifiers)) return reuse();
      if (STATIC()) return accept();
      if (ABSTRACT()) return accept();
      if (OVERRIDE()) return accept();
      if (FINAL()) return accept();
      if (NATIVE()) return accept();
      if (BLTCONREADONLY()) return accept();
      if (INLINE()) return accept();
      if (BLTCONPURE()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  functionDefinition = CONSTRUCTOR formalTypeArguments LPAR
  //    functionArgumentsExpr LWING initializeBlock / ident
  //    formalTypeArguments LPAR functionArgumentsExpr COLON
  //    typeDeclaration (SEMI / LWING block) ;
  //=====================================================================
  private boolean functionDefinition()
    {
      if (saved(functionDefinition)) return reuse();
      if (functionDefinition_0()) return accept();
      if (functionDefinition_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  functionDefinition_0 = CONSTRUCTOR formalTypeArguments LPAR
  //    functionArgumentsExpr LWING initializeBlock
  //-------------------------------------------------------------------
  private boolean functionDefinition_0()
    {
      if (savedInner(functionDefinition_0)) return reuseInner();
      if (!CONSTRUCTOR()) return rejectInner();
      formalTypeArguments();
      if (!LPAR()) return rejectInner();
      if (!functionArgumentsExpr()) return rejectInner();
      if (!LWING()) return rejectInner();
      initializeBlock();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  functionDefinition_1 = ident formalTypeArguments LPAR
  //    functionArgumentsExpr COLON typeDeclaration (SEMI / LWING
  //    block)
  //-------------------------------------------------------------------
  private boolean functionDefinition_1()
    {
      if (savedInner(functionDefinition_1)) return reuseInner();
      if (!ident()) return rejectInner();
      formalTypeArguments();
      if (!LPAR()) return rejectInner();
      if (!functionArgumentsExpr()) return rejectInner();
      if (!COLON()) return rejectInner();
      typeDeclaration();
      if (!SEMI()
       && !functionDefinition_2()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  functionDefinition_2 = LWING block
  //-------------------------------------------------------------------
  private boolean functionDefinition_2()
    {
      if (savedInner(functionDefinition_2)) return reuseInner();
      if (!LWING()) return rejectInner();
      if (!block()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  formalTypeArguments = (DOT LT ident (COMMA ident)* GT)? ;
  //=====================================================================
  private boolean formalTypeArguments()
    {
      if (saved(formalTypeArguments)) return reuse();
      formalTypeArguments_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  formalTypeArguments_0 = DOT LT ident (COMMA ident)* GT
  //-------------------------------------------------------------------
  private boolean formalTypeArguments_0()
    {
      if (savedInner(formalTypeArguments_0)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!LT()) return rejectInner();
      if (!ident()) return rejectInner();
      while (importStatement_2());
      if (!GT()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  actualTypeArguments = (DOT LT typeDeclaration (COMMA
  //    typeDeclaration)* GT)? ;
  //=====================================================================
  private boolean actualTypeArguments()
    {
      if (saved(actualTypeArguments)) return reuse();
      actualTypeArguments_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  actualTypeArguments_0 = DOT LT typeDeclaration (COMMA
  //    typeDeclaration)* GT
  //-------------------------------------------------------------------
  private boolean actualTypeArguments_0()
    {
      if (savedInner(actualTypeArguments_0)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!LT()) return rejectInner();
      typeDeclaration();
      while (actualTypeArguments_1());
      if (!GT()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  actualTypeArguments_1 = COMMA typeDeclaration
  //-------------------------------------------------------------------
  private boolean actualTypeArguments_1()
    {
      if (savedInner(actualTypeArguments_1)) return reuseInner();
      if (!COMMA()) return rejectInner();
      typeDeclaration();
      return acceptInner();
    }
  
  //=====================================================================
  //  typeDeclaration = VOID / typeDeclarationNoArrayNoVoid (LBRA RBRA)?
  //    ;
  //=====================================================================
  private boolean typeDeclaration()
    {
      if (saved(typeDeclaration)) return reuse();
      if (VOID()) return accept();
      if (typeDeclaration_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  typeDeclaration_0 = typeDeclarationNoArrayNoVoid (LBRA RBRA)?
  //-------------------------------------------------------------------
  private boolean typeDeclaration_0()
    {
      if (savedInner(typeDeclaration_0)) return reuseInner();
      typeDeclarationNoArrayNoVoid();
      typeDeclaration_1();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  typeDeclaration_1 = LBRA RBRA
  //-------------------------------------------------------------------
  private boolean typeDeclaration_1()
    {
      if (savedInner(typeDeclaration_1)) return reuseInner();
      if (!LBRA()) return rejectInner();
      if (!RBRA()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  typeDeclarationNoArrayNoVoid = MAYBEUNDEFINED / NULLABLE
  //    nullableTypeDeclaration / VARIANT / primaryTypeDeclaration ;
  //=====================================================================
  private boolean typeDeclarationNoArrayNoVoid()
    {
      if (saved(typeDeclarationNoArrayNoVoid)) return reuse();
      if (MAYBEUNDEFINED()) return accept();
      if (typeDeclarationNoArrayNoVoid_0()) return accept();
      if (VARIANT()) return accept();
      if (primaryTypeDeclaration()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  typeDeclarationNoArrayNoVoid_0 = NULLABLE
  //    nullableTypeDeclaration
  //-------------------------------------------------------------------
  private boolean typeDeclarationNoArrayNoVoid_0()
    {
      if (savedInner(typeDeclarationNoArrayNoVoid_0)) return reuseInner();
      if (!NULLABLE()) return rejectInner();
      if (!nullableTypeDeclaration()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  nullableTypeDeclaration = DOT LT typeDeclaration GT ;
  //=====================================================================
  private boolean nullableTypeDeclaration()
    {
      if (saved(nullableTypeDeclaration)) return reuse();
      if (!DOT()) return reject();
      if (!LT()) return reject();
      typeDeclaration();
      if (!GT()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  primaryTypeDeclaration = LPAR lightFunctionTypeDeclaration /
  //    FUNCTION functionTypeDeclaration / BOOLEAN / INT / NUMBER /
  //    STRING / objectTypeDeclaration ;
  //=====================================================================
  private boolean primaryTypeDeclaration()
    {
      if (saved(primaryTypeDeclaration)) return reuse();
      if (primaryTypeDeclaration_0()) return accept();
      if (primaryTypeDeclaration_1()) return accept();
      if (BOOLEAN()) return accept();
      if (INT()) return accept();
      if (NUMBER()) return accept();
      if (STRING()) return accept();
      if (objectTypeDeclaration()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  primaryTypeDeclaration_0 = LPAR lightFunctionTypeDeclaration
  //-------------------------------------------------------------------
  private boolean primaryTypeDeclaration_0()
    {
      if (savedInner(primaryTypeDeclaration_0)) return reuseInner();
      if (!LPAR()) return rejectInner();
      if (!lightFunctionTypeDeclaration()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  primaryTypeDeclaration_1 = FUNCTION functionTypeDeclaration
  //-------------------------------------------------------------------
  private boolean primaryTypeDeclaration_1()
    {
      if (savedInner(primaryTypeDeclaration_1)) return reuseInner();
      if (!FUNCTION()) return rejectInner();
      if (!functionTypeDeclaration()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  objectTypeDeclaration = ((SUPER / ident) actualTypeArguments)? (DOT
  //    ident)? actualTypeArguments ;
  //=====================================================================
  private boolean objectTypeDeclaration()
    {
      if (saved(objectTypeDeclaration)) return reuse();
      objectTypeDeclaration_0();
      objectTypeDeclaration_1();
      actualTypeArguments();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  objectTypeDeclaration_0 = (SUPER / ident) actualTypeArguments
  //-------------------------------------------------------------------
  private boolean objectTypeDeclaration_0()
    {
      if (savedInner(objectTypeDeclaration_0)) return reuseInner();
      if (!SUPER()
       && !ident()
         ) return rejectInner();
      actualTypeArguments();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  objectTypeDeclaration_1 = DOT ident
  //-------------------------------------------------------------------
  private boolean objectTypeDeclaration_1()
    {
      if (savedInner(objectTypeDeclaration_1)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!ident()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  lightFunctionTypeDeclaration = ARGS? typeDeclaration (COMMA ARGS?
  //    typeDeclaration)* RPAR ARROW typeDeclaration ;
  //=====================================================================
  private boolean lightFunctionTypeDeclaration()
    {
      if (saved(lightFunctionTypeDeclaration)) return reuse();
      ARGS();
      typeDeclaration();
      while (lightFunctionTypeDeclaration_0());
      if (!RPAR()) return reject();
      if (!ARROW()) return reject();
      typeDeclaration();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  lightFunctionTypeDeclaration_0 = COMMA ARGS? typeDeclaration
  //-------------------------------------------------------------------
  private boolean lightFunctionTypeDeclaration_0()
    {
      if (savedInner(lightFunctionTypeDeclaration_0)) return reuseInner();
      if (!COMMA()) return rejectInner();
      ARGS();
      typeDeclaration();
      return acceptInner();
    }
  
  //=====================================================================
  //  functionTypeDeclaration = ident? LPAR (ARGS ident? COLON
  //    typeDeclaration RPAR)? COLON typeDeclaration / ident? LPAR
  //    (ident? COLON typeDeclaration) (COMMA ident? COLON
  //    typeDeclaration)* COMMA (ARGS ident? COLON typeDeclaration RPAR)?
  //    COLON typeDeclaration ;
  //=====================================================================
  private boolean functionTypeDeclaration()
    {
      if (saved(functionTypeDeclaration)) return reuse();
      if (functionTypeDeclaration_0()) return accept();
      if (functionTypeDeclaration_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  functionTypeDeclaration_0 = ident? LPAR (ARGS ident? COLON
  //    typeDeclaration RPAR)? COLON typeDeclaration
  //-------------------------------------------------------------------
  private boolean functionTypeDeclaration_0()
    {
      if (savedInner(functionTypeDeclaration_0)) return reuseInner();
      ident();
      if (!LPAR()) return rejectInner();
      functionTypeDeclaration_2();
      if (!COLON()) return rejectInner();
      typeDeclaration();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  functionTypeDeclaration_1 = ident? LPAR (ident? COLON
  //    typeDeclaration) (COMMA ident? COLON typeDeclaration)* COMMA
  //    (ARGS ident? COLON typeDeclaration RPAR)? COLON
  //    typeDeclaration
  //-------------------------------------------------------------------
  private boolean functionTypeDeclaration_1()
    {
      if (savedInner(functionTypeDeclaration_1)) return reuseInner();
      ident();
      if (!LPAR()) return rejectInner();
      ident();
      if (!COLON()) return rejectInner();
      typeDeclaration();
      while (functionTypeDeclaration_3());
      if (!COMMA()) return rejectInner();
      functionTypeDeclaration_2();
      if (!COLON()) return rejectInner();
      typeDeclaration();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  functionTypeDeclaration_2 = ARGS ident? COLON typeDeclaration
  //    RPAR
  //-------------------------------------------------------------------
  private boolean functionTypeDeclaration_2()
    {
      if (savedInner(functionTypeDeclaration_2)) return reuseInner();
      if (!ARGS()) return rejectInner();
      ident();
      if (!COLON()) return rejectInner();
      typeDeclaration();
      if (!RPAR()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  functionTypeDeclaration_3 = COMMA ident? COLON typeDeclaration
  //-------------------------------------------------------------------
  private boolean functionTypeDeclaration_3()
    {
      if (savedInner(functionTypeDeclaration_3)) return reuseInner();
      if (!COMMA()) return rejectInner();
      ident();
      if (!COLON()) return rejectInner();
      typeDeclaration();
      return acceptInner();
    }
  
  //=====================================================================
  //  initializeBlock = constructorInvocationStatement* (block? / RWING)
  //    ;
  //=====================================================================
  private boolean initializeBlock()
    {
      if (saved(initializeBlock)) return reuse();
      while (constructorInvocationStatement());
      if (!initializeBlock_0()
       && !RWING()
         ) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  initializeBlock_0 = block?
  //-------------------------------------------------------------------
  private boolean initializeBlock_0()
    {
      if (savedInner(initializeBlock_0)) return reuseInner();
      block();
      return acceptInner();
    }
  
  //=====================================================================
  //  block = statement* RWING ;
  //=====================================================================
  private boolean block()
    {
      if (saved(block)) return reuse();
      while (statement());
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  statement = SEMI / VAR variableStatement / IF ifStatement /
  //    CONTINUE continueStatement / BREAK breakStatement / RETURN
  //    returnStatement / THROW throwStatement / TRY tryStatement /
  //    ASSERT assertStatement / LOG logStatement / DELETE
  //    deleteStatement / DEBUGGER debuggerStatement / FUNCTION
  //    functionStatement / VOID / LWING block / expr SEMI / (ident
  //    SEMI)? DO doWhileStatement / (ident SEMI)? WHILE whileStatement /
  //    (ident SEMI)? FOR forStatement / (ident SEMI)? SWITCH
  //    switchStatement ;
  //=====================================================================
  private boolean statement()
    {
      if (saved(statement)) return reuse();
      if (SEMI()) return accept();
      if (statement_0()) return accept();
      if (statement_1()) return accept();
      if (statement_2()) return accept();
      if (statement_3()) return accept();
      if (statement_4()) return accept();
      if (statement_5()) return accept();
      if (statement_6()) return accept();
      if (statement_7()) return accept();
      if (statement_8()) return accept();
      if (statement_9()) return accept();
      if (statement_10()) return accept();
      if (statement_11()) return accept();
      if (VOID()) return accept();
      if (functionDefinition_2()) return accept();
      if (statement_12()) return accept();
      if (statement_13()) return accept();
      if (statement_14()) return accept();
      if (statement_15()) return accept();
      if (statement_16()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  statement_0 = VAR variableStatement
  //-------------------------------------------------------------------
  private boolean statement_0()
    {
      if (savedInner(statement_0)) return reuseInner();
      if (!VAR()) return rejectInner();
      if (!variableStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_1 = IF ifStatement
  //-------------------------------------------------------------------
  private boolean statement_1()
    {
      if (savedInner(statement_1)) return reuseInner();
      if (!IF()) return rejectInner();
      if (!ifStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_2 = CONTINUE continueStatement
  //-------------------------------------------------------------------
  private boolean statement_2()
    {
      if (savedInner(statement_2)) return reuseInner();
      if (!CONTINUE()) return rejectInner();
      if (!continueStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_3 = BREAK breakStatement
  //-------------------------------------------------------------------
  private boolean statement_3()
    {
      if (savedInner(statement_3)) return reuseInner();
      if (!BREAK()) return rejectInner();
      if (!breakStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_4 = RETURN returnStatement
  //-------------------------------------------------------------------
  private boolean statement_4()
    {
      if (savedInner(statement_4)) return reuseInner();
      if (!RETURN()) return rejectInner();
      if (!returnStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_5 = THROW throwStatement
  //-------------------------------------------------------------------
  private boolean statement_5()
    {
      if (savedInner(statement_5)) return reuseInner();
      if (!THROW()) return rejectInner();
      if (!throwStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_6 = TRY tryStatement
  //-------------------------------------------------------------------
  private boolean statement_6()
    {
      if (savedInner(statement_6)) return reuseInner();
      if (!TRY()) return rejectInner();
      if (!tryStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_7 = ASSERT assertStatement
  //-------------------------------------------------------------------
  private boolean statement_7()
    {
      if (savedInner(statement_7)) return reuseInner();
      if (!ASSERT()) return rejectInner();
      if (!assertStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_8 = LOG logStatement
  //-------------------------------------------------------------------
  private boolean statement_8()
    {
      if (savedInner(statement_8)) return reuseInner();
      if (!LOG()) return rejectInner();
      if (!logStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_9 = DELETE deleteStatement
  //-------------------------------------------------------------------
  private boolean statement_9()
    {
      if (savedInner(statement_9)) return reuseInner();
      if (!DELETE()) return rejectInner();
      if (!deleteStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_10 = DEBUGGER debuggerStatement
  //-------------------------------------------------------------------
  private boolean statement_10()
    {
      if (savedInner(statement_10)) return reuseInner();
      if (!DEBUGGER()) return rejectInner();
      if (!debuggerStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_11 = FUNCTION functionStatement
  //-------------------------------------------------------------------
  private boolean statement_11()
    {
      if (savedInner(statement_11)) return reuseInner();
      if (!FUNCTION()) return rejectInner();
      if (!functionStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_12 = expr SEMI
  //-------------------------------------------------------------------
  private boolean statement_12()
    {
      if (savedInner(statement_12)) return reuseInner();
      if (!expr()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_13 = (ident SEMI)? DO doWhileStatement
  //-------------------------------------------------------------------
  private boolean statement_13()
    {
      if (savedInner(statement_13)) return reuseInner();
      statement_17();
      if (!DO()) return rejectInner();
      if (!doWhileStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_14 = (ident SEMI)? WHILE whileStatement
  //-------------------------------------------------------------------
  private boolean statement_14()
    {
      if (savedInner(statement_14)) return reuseInner();
      statement_17();
      if (!WHILE()) return rejectInner();
      if (!whileStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_15 = (ident SEMI)? FOR forStatement
  //-------------------------------------------------------------------
  private boolean statement_15()
    {
      if (savedInner(statement_15)) return reuseInner();
      statement_17();
      if (!FOR()) return rejectInner();
      if (!forStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_16 = (ident SEMI)? SWITCH switchStatement
  //-------------------------------------------------------------------
  private boolean statement_16()
    {
      if (savedInner(statement_16)) return reuseInner();
      statement_17();
      if (!SWITCH()) return rejectInner();
      if (!switchStatement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  statement_17 = ident SEMI
  //-------------------------------------------------------------------
  private boolean statement_17()
    {
      if (savedInner(statement_17)) return reuseInner();
      if (!ident()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  assignExpr = "a" ;
  //=====================================================================
  private boolean assignExpr()
    {
      if (saved(assignExpr)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  tryStatement = "a" ;
  //=====================================================================
  private boolean tryStatement()
    {
      if (saved(tryStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  logStatement = "a" ;
  //=====================================================================
  private boolean logStatement()
    {
      if (saved(logStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  breakStatement = "a" ;
  //=====================================================================
  private boolean breakStatement()
    {
      if (saved(breakStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  switchStatement = "a" ;
  //=====================================================================
  private boolean switchStatement()
    {
      if (saved(switchStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  continueStatement = "a" ;
  //=====================================================================
  private boolean continueStatement()
    {
      if (saved(continueStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  forStatement = "a" ;
  //=====================================================================
  private boolean forStatement()
    {
      if (saved(forStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  doWhileStatement = "a" ;
  //=====================================================================
  private boolean doWhileStatement()
    {
      if (saved(doWhileStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  functionStatement = "a" ;
  //=====================================================================
  private boolean functionStatement()
    {
      if (saved(functionStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  throwStatement = "a" ;
  //=====================================================================
  private boolean throwStatement()
    {
      if (saved(throwStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  returnStatement = "a" ;
  //=====================================================================
  private boolean returnStatement()
    {
      if (saved(returnStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  variableStatement = "a" ;
  //=====================================================================
  private boolean variableStatement()
    {
      if (saved(variableStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  deleteStatement = "a" ;
  //=====================================================================
  private boolean deleteStatement()
    {
      if (saved(deleteStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  debuggerStatement = "a" ;
  //=====================================================================
  private boolean debuggerStatement()
    {
      if (saved(debuggerStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  assertStatement = "a" ;
  //=====================================================================
  private boolean assertStatement()
    {
      if (saved(assertStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ifStatement = "a" ;
  //=====================================================================
  private boolean ifStatement()
    {
      if (saved(ifStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  whileStatement = "a" ;
  //=====================================================================
  private boolean whileStatement()
    {
      if (saved(whileStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  constructorInvocationStatement = "a" ;
  //=====================================================================
  private boolean constructorInvocationStatement()
    {
      if (saved(constructorInvocationStatement)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  expr = "a" ;
  //=====================================================================
  private boolean expr()
    {
      if (saved(expr)) return reuse();
      if (!next('a')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ident = ([a-z] / [A-Z] / "_") ([a-z] / [A-Z] / "_" / [0-9])*
  //    spacing ;
  //=====================================================================
  private boolean ident()
    {
      if (saved(ident)) return reuse();
      if (!nextIn('a','z')
       && !nextIn('A','Z')
       && !next('_')
         ) return reject();
      while (ident_0());
      spacing();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ident_0 = [a-z] / [A-Z] / "_" / [0-9]
  //-------------------------------------------------------------------
  private boolean ident_0()
    {
      if (savedInner(ident_0)) return reuseInner();
      if (nextIn('a','z')) return acceptInner();
      if (nextIn('A','Z')) return acceptInner();
      if (next('_')) return acceptInner();
      if (nextIn('0','9')) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  nullLiteral = (":" typeDeclaration)? ;
  //=====================================================================
  private boolean nullLiteral()
    {
      if (saved(nullLiteral)) return reuse();
      nullLiteral_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  nullLiteral_0 = ":" typeDeclaration
  //-------------------------------------------------------------------
  private boolean nullLiteral_0()
    {
      if (savedInner(nullLiteral_0)) return reuseInner();
      if (!next(':')) return rejectInner();
      typeDeclaration();
      return acceptInner();
    }
  
  //=====================================================================
  //  arrayLiteral = (assignExpr ("," assignExpr)*)? "]" (":"
  //    typeDeclaration)? ;
  //=====================================================================
  private boolean arrayLiteral()
    {
      if (saved(arrayLiteral)) return reuse();
      arrayLiteral_0();
      if (!next(']')) return reject();
      nullLiteral_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  arrayLiteral_0 = assignExpr ("," assignExpr)*
  //-------------------------------------------------------------------
  private boolean arrayLiteral_0()
    {
      if (savedInner(arrayLiteral_0)) return reuseInner();
      if (!assignExpr()) return rejectInner();
      while (arrayLiteral_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  arrayLiteral_1 = "," assignExpr
  //-------------------------------------------------------------------
  private boolean arrayLiteral_1()
    {
      if (savedInner(arrayLiteral_1)) return reuseInner();
      if (!next(',')) return rejectInner();
      if (!assignExpr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  hashLiteral = ((ident / numberLiteral / string) COLON assignExpr
  //    (COMMA (ident / numberLiteral / string) COLON assignExpr)*)? RBRA
  //    (COLON typeDeclaration)? ;
  //=====================================================================
  private boolean hashLiteral()
    {
      if (saved(hashLiteral)) return reuse();
      hashLiteral_0();
      if (!RBRA()) return reject();
      memberDefinition_3();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  hashLiteral_0 = (ident / numberLiteral / string) COLON assignExpr
  //    (COMMA (ident / numberLiteral / string) COLON assignExpr)*
  //-------------------------------------------------------------------
  private boolean hashLiteral_0()
    {
      if (savedInner(hashLiteral_0)) return reuseInner();
      if (!ident()
       && !numberLiteral()
       && !string()
         ) return rejectInner();
      if (!COLON()) return rejectInner();
      if (!assignExpr()) return rejectInner();
      while (hashLiteral_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  hashLiteral_1 = COMMA (ident / numberLiteral / string) COLON
  //    assignExpr
  //-------------------------------------------------------------------
  private boolean hashLiteral_1()
    {
      if (savedInner(hashLiteral_1)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!ident()
       && !numberLiteral()
       && !string()
         ) return rejectInner();
      if (!COLON()) return rejectInner();
      if (!assignExpr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  functionArgumentsExpr = RPAR / (ARGS ident / ident)? (COLON
  //    typeDeclaration)? (COMMA (ARGS ident / ident)? (COLON
  //    typeDeclaration)?)* RPAR ;
  //=====================================================================
  private boolean functionArgumentsExpr()
    {
      if (saved(functionArgumentsExpr)) return reuse();
      if (RPAR()) return accept();
      if (functionArgumentsExpr_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  functionArgumentsExpr_0 = (ARGS ident / ident)? (COLON
  //    typeDeclaration)? (COMMA (ARGS ident / ident)? (COLON
  //    typeDeclaration)?)* RPAR
  //-------------------------------------------------------------------
  private boolean functionArgumentsExpr_0()
    {
      if (savedInner(functionArgumentsExpr_0)) return reuseInner();
      functionArgumentsExpr_1();
      memberDefinition_3();
      while (functionArgumentsExpr_2());
      if (!RPAR()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  functionArgumentsExpr_1 = ARGS ident / ident
  //-------------------------------------------------------------------
  private boolean functionArgumentsExpr_1()
    {
      if (savedInner(functionArgumentsExpr_1)) return reuseInner();
      if (functionArgumentsExpr_3()) return acceptInner();
      if (ident()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  functionArgumentsExpr_2 = COMMA (ARGS ident / ident)? (COLON
  //    typeDeclaration)?
  //-------------------------------------------------------------------
  private boolean functionArgumentsExpr_2()
    {
      if (savedInner(functionArgumentsExpr_2)) return reuseInner();
      if (!COMMA()) return rejectInner();
      functionArgumentsExpr_1();
      memberDefinition_3();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  functionArgumentsExpr_3 = ARGS ident
  //-------------------------------------------------------------------
  private boolean functionArgumentsExpr_3()
    {
      if (savedInner(functionArgumentsExpr_3)) return reuseInner();
      if (!ARGS()) return rejectInner();
      if (!ident()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  argsExpr = RPAR / assignExpr (COMMA assignExpr)* RPAR ;
  //=====================================================================
  private boolean argsExpr()
    {
      if (saved(argsExpr)) return reuse();
      if (RPAR()) return accept();
      if (argsExpr_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  argsExpr_0 = assignExpr (COMMA assignExpr)* RPAR
  //-------------------------------------------------------------------
  private boolean argsExpr_0()
    {
      if (savedInner(argsExpr_0)) return reuseInner();
      if (!assignExpr()) return rejectInner();
      while (argsExpr_1());
      if (!RPAR()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  argsExpr_1 = COMMA assignExpr
  //-------------------------------------------------------------------
  private boolean argsExpr_1()
    {
      if (savedInner(argsExpr_1)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!assignExpr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  string = doubleQuoted spacing? / singleQuoted spacing? ;
  //=====================================================================
  private boolean string()
    {
      if (saved(string)) return reuse();
      if (string_0()) return accept();
      if (string_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  string_0 = doubleQuoted spacing?
  //-------------------------------------------------------------------
  private boolean string_0()
    {
      if (savedInner(string_0)) return reuseInner();
      if (!doubleQuoted()) return rejectInner();
      spacing();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  string_1 = singleQuoted spacing?
  //-------------------------------------------------------------------
  private boolean string_1()
    {
      if (savedInner(string_1)) return reuseInner();
      if (!singleQuoted()) return rejectInner();
      spacing();
      return acceptInner();
    }
  
  //=====================================================================
  //  doubleQuoted = """ ^["\]* ("\" _ (!""" !"\" _)*)* """ ;
  //=====================================================================
  private boolean doubleQuoted()
    {
      if (saved(doubleQuoted)) return reuse();
      if (!next('"')) return reject();
      while (nextNotIn("\"\\"));
      while (doubleQuoted_0());
      if (!next('"')) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  doubleQuoted_0 = "\" _ (!""" !"\" _)*
  //-------------------------------------------------------------------
  private boolean doubleQuoted_0()
    {
      if (savedInner(doubleQuoted_0)) return reuseInner();
      if (!next('\\')) return rejectInner();
      if (!next()) return rejectInner();
      while (doubleQuoted_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  doubleQuoted_1 = !""" !"\" _
  //-------------------------------------------------------------------
  private boolean doubleQuoted_1()
    {
      if (savedInner(doubleQuoted_1)) return reuseInner();
      if (!aheadNot('"')) return rejectInner();
      if (!aheadNot('\\')) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  singleQuoted = "'" (!"'" !"\" _)* ("\" _ (!"'" !"\" _)*)* "'" ;
  //=====================================================================
  private boolean singleQuoted()
    {
      if (saved(singleQuoted)) return reuse();
      if (!next('\'')) return reject();
      while (singleQuoted_0());
      while (singleQuoted_1());
      if (!next('\'')) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  singleQuoted_0 = !"'" !"\" _
  //-------------------------------------------------------------------
  private boolean singleQuoted_0()
    {
      if (savedInner(singleQuoted_0)) return reuseInner();
      if (!aheadNot('\'')) return rejectInner();
      if (!aheadNot('\\')) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  singleQuoted_1 = "\" _ (!"'" !"\" _)*
  //-------------------------------------------------------------------
  private boolean singleQuoted_1()
    {
      if (savedInner(singleQuoted_1)) return reuseInner();
      if (!next('\\')) return rejectInner();
      if (!next()) return rejectInner();
      while (singleQuoted_0());
      return acceptInner();
    }
  
  //=====================================================================
  //  regexp = "/" (!"/" !"\" _)* ("\" _ (!"/" !"\" _)*)* "/" ("m" / "g"
  //    / "i")* ;
  //=====================================================================
  private boolean regexp()
    {
      if (saved(regexp)) return reuse();
      if (!next('/')) return reject();
      while (regexp_0());
      while (regexp_1());
      if (!next('/')) return reject();
      while (regexp_2());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  regexp_0 = !"/" !"\" _
  //-------------------------------------------------------------------
  private boolean regexp_0()
    {
      if (savedInner(regexp_0)) return reuseInner();
      if (!aheadNot('/')) return rejectInner();
      if (!aheadNot('\\')) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  regexp_1 = "\" _ (!"/" !"\" _)*
  //-------------------------------------------------------------------
  private boolean regexp_1()
    {
      if (savedInner(regexp_1)) return reuseInner();
      if (!next('\\')) return rejectInner();
      if (!next()) return rejectInner();
      while (regexp_0());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  regexp_2 = "m" / "g" / "i"
  //-------------------------------------------------------------------
  private boolean regexp_2()
    {
      if (savedInner(regexp_2)) return reuseInner();
      if (next('m')) return acceptInner();
      if (next('g')) return acceptInner();
      if (next('i')) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  numberLiteral = numberLiteral2 / integerLiteral ;
  //=====================================================================
  private boolean numberLiteral()
    {
      if (saved(numberLiteral)) return reuse();
      if (numberLiteral2()) return accept();
      if (integerLiteral()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  decimalIntegerLiteral = "0" / [1-9] [0-9]* ;
  //=====================================================================
  private boolean decimalIntegerLiteral()
    {
      if (saved(decimalIntegerLiteral)) return reuse();
      if (next('0')) return accept();
      if (decimalIntegerLiteral_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  decimalIntegerLiteral_0 = [1-9] [0-9]*
  //-------------------------------------------------------------------
  private boolean decimalIntegerLiteral_0()
    {
      if (savedInner(decimalIntegerLiteral_0)) return reuseInner();
      if (!nextIn('1','9')) return rejectInner();
      while (nextIn('0','9'));
      return acceptInner();
    }
  
  //=====================================================================
  //  exponentPart = [eE] [+-]? [0-9]+ ;
  //=====================================================================
  private boolean exponentPart()
    {
      if (saved(exponentPart)) return reuse();
      if (!nextIn("eE")) return reject();
      nextIn("+-");
      if (!nextIn('0','9')) return reject();
      while (nextIn('0','9'));
      return accept();
    }
  
  //=====================================================================
  //  numberLiteral2 = decimalIntegerLiteral ("." [0-9]*)? exponentPart?
  //    / "." [0-9]+ exponentPart? / "NaN" / "Infinity" ;
  //=====================================================================
  private boolean numberLiteral2()
    {
      if (saved(numberLiteral2)) return reuse();
      if (numberLiteral2_0()) return accept();
      if (numberLiteral2_1()) return accept();
      if (next("NaN")) return accept();
      if (next("Infinity")) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  numberLiteral2_0 = decimalIntegerLiteral ("." [0-9]*)?
  //    exponentPart?
  //-------------------------------------------------------------------
  private boolean numberLiteral2_0()
    {
      if (savedInner(numberLiteral2_0)) return reuseInner();
      if (!decimalIntegerLiteral()) return rejectInner();
      numberLiteral2_2();
      exponentPart();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  numberLiteral2_1 = "." [0-9]+ exponentPart?
  //-------------------------------------------------------------------
  private boolean numberLiteral2_1()
    {
      if (savedInner(numberLiteral2_1)) return reuseInner();
      if (!next('.')) return rejectInner();
      if (!nextIn('0','9')) return rejectInner();
      while (nextIn('0','9'));
      exponentPart();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  numberLiteral2_2 = "." [0-9]*
  //-------------------------------------------------------------------
  private boolean numberLiteral2_2()
    {
      if (savedInner(numberLiteral2_2)) return reuseInner();
      if (!next('.')) return rejectInner();
      while (nextIn('0','9'));
      return acceptInner();
    }
  
  //=====================================================================
  //  integerLiteral = "0" [xX] [0-9a-fA-F]+ / decimalIntegerLiteral ;
  //=====================================================================
  private boolean integerLiteral()
    {
      if (saved(integerLiteral)) return reuse();
      if (integerLiteral_0()) return accept();
      if (decimalIntegerLiteral()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  integerLiteral_0 = "0" [xX] [0-9a-fA-F]+
  //-------------------------------------------------------------------
  private boolean integerLiteral_0()
    {
      if (savedInner(integerLiteral_0)) return reuseInner();
      if (!next('0')) return rejectInner();
      if (!nextIn("xX")) return rejectInner();
      if (!nextIn("0-9a-fA-F")) return rejectInner();
      while (nextIn("0-9a-fA-F"));
      return acceptInner();
    }
  
  //=====================================================================
  //  multilineComment = "/*" (!"*/" _)* "*/" ;
  //=====================================================================
  private boolean multilineComment()
    {
      if (saved(multilineComment)) return reuse();
      if (!next("/*")) return reject();
      while (multilineComment_0());
      if (!next("*/")) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  multilineComment_0 = !"*/" _
  //-------------------------------------------------------------------
  private boolean multilineComment_0()
    {
      if (savedInner(multilineComment_0)) return reuseInner();
      if (!aheadNot("*/")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  singlelineComment = "//" (!"\n" !"\r" _)* ("\r" / "\r\n" / "\n") ;
  //=====================================================================
  private boolean singlelineComment()
    {
      if (saved(singlelineComment)) return reuse();
      if (!next("//")) return reject();
      while (singlelineComment_0());
      if (!next('\r')
       && !next("\r\n")
       && !next('\n')
         ) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  singlelineComment_0 = !"\n" !"\r" _
  //-------------------------------------------------------------------
  private boolean singlelineComment_0()
    {
      if (savedInner(singlelineComment_0)) return reuseInner();
      if (!aheadNot('\n')) return rejectInner();
      if (!aheadNot('\r')) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  spacing = (space / multilineComment / singlelineComment)* ;
  //=====================================================================
  private boolean spacing()
    {
      if (saved(spacing)) return reuse();
      while (spacing_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  spacing_0 = space / multilineComment / singlelineComment
  //-------------------------------------------------------------------
  private boolean spacing_0()
    {
      if (savedInner(spacing_0)) return reuseInner();
      if (space()) return acceptInner();
      if (multilineComment()) return acceptInner();
      if (singlelineComment()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  space = [ \t\r\n] ;
  //=====================================================================
  private boolean space()
    {
      if (saved(space)) return reuse();
      if (!nextIn(" \t\r\n")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  NOT = "!" spacing ;
  //=====================================================================
  private boolean NOT()
    {
      if (saved(NOT)) return reuse();
      if (!next('!')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  NOTEQ = "!=" spacing ;
  //=====================================================================
  private boolean NOTEQ()
    {
      if (saved(NOTEQ)) return reuse();
      if (!next("!=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  SUR = "%" spacing ;
  //=====================================================================
  private boolean SUR()
    {
      if (saved(SUR)) return reuse();
      if (!next('%')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  SUREEQ = "%=" spacing ;
  //=====================================================================
  private boolean SUREEQ()
    {
      if (saved(SUREEQ)) return reuse();
      if (!next("%=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  AND = "&&" spacing ;
  //=====================================================================
  private boolean AND()
    {
      if (saved(AND)) return reuse();
      if (!next("&&")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  BITAND = "&" spacing ;
  //=====================================================================
  private boolean BITAND()
    {
      if (saved(BITAND)) return reuse();
      if (!next('&')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  BITANDEQ = "&=" spacing ;
  //=====================================================================
  private boolean BITANDEQ()
    {
      if (saved(BITANDEQ)) return reuse();
      if (!next("&=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  LPAR = "(" spacing ;
  //=====================================================================
  private boolean LPAR()
    {
      if (saved(LPAR)) return reuse();
      if (!next('(')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  RPAR = ")" spacing ;
  //=====================================================================
  private boolean RPAR()
    {
      if (saved(RPAR)) return reuse();
      if (!next(')')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  MUL = "*" spacing ;
  //=====================================================================
  private boolean MUL()
    {
      if (saved(MUL)) return reuse();
      if (!next('*')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  MULEQ = "*=" spacing ;
  //=====================================================================
  private boolean MULEQ()
    {
      if (saved(MULEQ)) return reuse();
      if (!next("*=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  ADD = "+" spacing ;
  //=====================================================================
  private boolean ADD()
    {
      if (saved(ADD)) return reuse();
      if (!next('+')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  INC = "++" spacing ;
  //=====================================================================
  private boolean INC()
    {
      if (saved(INC)) return reuse();
      if (!next("++")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  ADDEQ = "+=" spacing ;
  //=====================================================================
  private boolean ADDEQ()
    {
      if (saved(ADDEQ)) return reuse();
      if (!next("+=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  COMMA = "," spacing ;
  //=====================================================================
  private boolean COMMA()
    {
      if (saved(COMMA)) return reuse();
      if (!next(',')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  SUB = "-" spacing ;
  //=====================================================================
  private boolean SUB()
    {
      if (saved(SUB)) return reuse();
      if (!next('-')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  DEC = "--" spacing ;
  //=====================================================================
  private boolean DEC()
    {
      if (saved(DEC)) return reuse();
      if (!next("--")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  SUBEQ = "-=" spacing ;
  //=====================================================================
  private boolean SUBEQ()
    {
      if (saved(SUBEQ)) return reuse();
      if (!next("-=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  ARROW = "->" spacing ;
  //=====================================================================
  private boolean ARROW()
    {
      if (saved(ARROW)) return reuse();
      if (!next("->")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  DOT = "." spacing ;
  //=====================================================================
  private boolean DOT()
    {
      if (saved(DOT)) return reuse();
      if (!next('.')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  ARGS = "..." spacing ;
  //=====================================================================
  private boolean ARGS()
    {
      if (saved(ARGS)) return reuse();
      if (!next("...")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  DIV = "/" spacing ;
  //=====================================================================
  private boolean DIV()
    {
      if (saved(DIV)) return reuse();
      if (!next('/')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  DIVEQ = "/=" spacing ;
  //=====================================================================
  private boolean DIVEQ()
    {
      if (saved(DIVEQ)) return reuse();
      if (!next("/=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  COLON = ":" spacing ;
  //=====================================================================
  private boolean COLON()
    {
      if (saved(COLON)) return reuse();
      if (!next(':')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  SEMI = ";" spacing ;
  //=====================================================================
  private boolean SEMI()
    {
      if (saved(SEMI)) return reuse();
      if (!next(';')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  LT = "<" spacing ;
  //=====================================================================
  private boolean LT()
    {
      if (saved(LT)) return reuse();
      if (!next('<')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  LSHIFT = "<<" spacing ;
  //=====================================================================
  private boolean LSHIFT()
    {
      if (saved(LSHIFT)) return reuse();
      if (!next("<<")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  LSHIFTEQ = "<<=" spacing ;
  //=====================================================================
  private boolean LSHIFTEQ()
    {
      if (saved(LSHIFTEQ)) return reuse();
      if (!next("<<=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  LTEQ = "<=" spacing ;
  //=====================================================================
  private boolean LTEQ()
    {
      if (saved(LTEQ)) return reuse();
      if (!next("<=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  ASSIGN = "=" spacing ;
  //=====================================================================
  private boolean ASSIGN()
    {
      if (saved(ASSIGN)) return reuse();
      if (!next('=')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  EQ = "==" spacing ;
  //=====================================================================
  private boolean EQ()
    {
      if (saved(EQ)) return reuse();
      if (!next("==")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  GT = ">" spacing ;
  //=====================================================================
  private boolean GT()
    {
      if (saved(GT)) return reuse();
      if (!next('>')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  GTEQ = ">=" spacing ;
  //=====================================================================
  private boolean GTEQ()
    {
      if (saved(GTEQ)) return reuse();
      if (!next(">=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  COND = "?" spacing ;
  //=====================================================================
  private boolean COND()
    {
      if (saved(COND)) return reuse();
      if (!next('?')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  LBRA = "[" spacing ;
  //=====================================================================
  private boolean LBRA()
    {
      if (saved(LBRA)) return reuse();
      if (!next('[')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  RBRA = "]" spacing ;
  //=====================================================================
  private boolean RBRA()
    {
      if (saved(RBRA)) return reuse();
      if (!next(']')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  XOR = "^" spacing ;
  //=====================================================================
  private boolean XOR()
    {
      if (saved(XOR)) return reuse();
      if (!next('^')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  XOREQ = "^=" spacing ;
  //=====================================================================
  private boolean XOREQ()
    {
      if (saved(XOREQ)) return reuse();
      if (!next("^=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  LWING = "{" spacing ;
  //=====================================================================
  private boolean LWING()
    {
      if (saved(LWING)) return reuse();
      if (!next('{')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  BITOR = "|" spacing ;
  //=====================================================================
  private boolean BITOR()
    {
      if (saved(BITOR)) return reuse();
      if (!next('|')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  BITOREQ = "|=" spacing ;
  //=====================================================================
  private boolean BITOREQ()
    {
      if (saved(BITOREQ)) return reuse();
      if (!next("|=")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  OR = "||" spacing ;
  //=====================================================================
  private boolean OR()
    {
      if (saved(OR)) return reuse();
      if (!next("||")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  RWING = "}" spacing ;
  //=====================================================================
  private boolean RWING()
    {
      if (saved(RWING)) return reuse();
      if (!next('}')) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  MAYBEUNDEFINED = "MayBeUndefined" spacing ;
  //=====================================================================
  private boolean MAYBEUNDEFINED()
    {
      if (saved(MAYBEUNDEFINED)) return reuse();
      if (!next("MayBeUndefined")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  NULLABLE = "Nullable" spacing ;
  //=====================================================================
  private boolean NULLABLE()
    {
      if (saved(NULLABLE)) return reuse();
      if (!next("Nullable")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  ABSTRACT = "abstract" spacing ;
  //=====================================================================
  private boolean ABSTRACT()
    {
      if (saved(ABSTRACT)) return reuse();
      if (!next("abstract")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  AS = "as" spacing ;
  //=====================================================================
  private boolean AS()
    {
      if (saved(AS)) return reuse();
      if (!next("as")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  ASSERT = "assert" spacing ;
  //=====================================================================
  private boolean ASSERT()
    {
      if (saved(ASSERT)) return reuse();
      if (!next("assert")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  BOOLEAN = "boolean" spacing ;
  //=====================================================================
  private boolean BOOLEAN()
    {
      if (saved(BOOLEAN)) return reuse();
      if (!next("boolean")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  BREAK = "break" spacing ;
  //=====================================================================
  private boolean BREAK()
    {
      if (saved(BREAK)) return reuse();
      if (!next("break")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  CASE = "case" spacing ;
  //=====================================================================
  private boolean CASE()
    {
      if (saved(CASE)) return reuse();
      if (!next("case")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  CATCH = "catch" spacing ;
  //=====================================================================
  private boolean CATCH()
    {
      if (saved(CATCH)) return reuse();
      if (!next("catch")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  CLASS = "class" spacing ;
  //=====================================================================
  private boolean CLASS()
    {
      if (saved(CLASS)) return reuse();
      if (!next("class")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  CONST = "const" spacing ;
  //=====================================================================
  private boolean CONST()
    {
      if (saved(CONST)) return reuse();
      if (!next("const")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  CONSTRUCTOR = "constructor" spacing ;
  //=====================================================================
  private boolean CONSTRUCTOR()
    {
      if (saved(CONSTRUCTOR)) return reuse();
      if (!next("constructor")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  CONTINUE = "continue" spacing ;
  //=====================================================================
  private boolean CONTINUE()
    {
      if (saved(CONTINUE)) return reuse();
      if (!next("continue")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  DEBUGGER = "debugger" spacing ;
  //=====================================================================
  private boolean DEBUGGER()
    {
      if (saved(DEBUGGER)) return reuse();
      if (!next("debugger")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  DEFAULT = "default" spacing ;
  //=====================================================================
  private boolean DEFAULT()
    {
      if (saved(DEFAULT)) return reuse();
      if (!next("default")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  DELETE = "delete" spacing ;
  //=====================================================================
  private boolean DELETE()
    {
      if (saved(DELETE)) return reuse();
      if (!next("delete")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  DO = "do" spacing ;
  //=====================================================================
  private boolean DO()
    {
      if (saved(DO)) return reuse();
      if (!next("do")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  ELSE = "else" spacing ;
  //=====================================================================
  private boolean ELSE()
    {
      if (saved(ELSE)) return reuse();
      if (!next("else")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  EXTENDS = "extends" spacing ;
  //=====================================================================
  private boolean EXTENDS()
    {
      if (saved(EXTENDS)) return reuse();
      if (!next("extends")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  FALSE = "false" spacing ;
  //=====================================================================
  private boolean FALSE()
    {
      if (saved(FALSE)) return reuse();
      if (!next("false")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  FINAL = "final" spacing ;
  //=====================================================================
  private boolean FINAL()
    {
      if (saved(FINAL)) return reuse();
      if (!next("final")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  FINALLY = "finally" spacing ;
  //=====================================================================
  private boolean FINALLY()
    {
      if (saved(FINALLY)) return reuse();
      if (!next("finally")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  FOR = "for" spacing ;
  //=====================================================================
  private boolean FOR()
    {
      if (saved(FOR)) return reuse();
      if (!next("for")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  FROM = "from" spacing ;
  //=====================================================================
  private boolean FROM()
    {
      if (saved(FROM)) return reuse();
      if (!next("from")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  FUNCTION = "function" spacing ;
  //=====================================================================
  private boolean FUNCTION()
    {
      if (saved(FUNCTION)) return reuse();
      if (!next("function")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  IF = "if" spacing ;
  //=====================================================================
  private boolean IF()
    {
      if (saved(IF)) return reuse();
      if (!next("if")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  IMPLEMENTS = "implements" spacing ;
  //=====================================================================
  private boolean IMPLEMENTS()
    {
      if (saved(IMPLEMENTS)) return reuse();
      if (!next("implements")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  IMPORT = "import" spacing ;
  //=====================================================================
  private boolean IMPORT()
    {
      if (saved(IMPORT)) return reuse();
      if (!next("import")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  IN = "in" spacing ;
  //=====================================================================
  private boolean IN()
    {
      if (saved(IN)) return reuse();
      if (!next("in")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  INLINE = "inline" spacing ;
  //=====================================================================
  private boolean INLINE()
    {
      if (saved(INLINE)) return reuse();
      if (!next("inline")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  INSTANCEOF = "instanceof" spacing ;
  //=====================================================================
  private boolean INSTANCEOF()
    {
      if (saved(INSTANCEOF)) return reuse();
      if (!next("instanceof")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  INT = "int" spacing ;
  //=====================================================================
  private boolean INT()
    {
      if (saved(INT)) return reuse();
      if (!next("int")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  INTERFACE = "interface" spacing ;
  //=====================================================================
  private boolean INTERFACE()
    {
      if (saved(INTERFACE)) return reuse();
      if (!next("interface")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  INTO = "into" spacing ;
  //=====================================================================
  private boolean INTO()
    {
      if (saved(INTO)) return reuse();
      if (!next("into")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  LOG = "log" spacing ;
  //=====================================================================
  private boolean LOG()
    {
      if (saved(LOG)) return reuse();
      if (!next("log")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  MIXIN = "mixin" spacing ;
  //=====================================================================
  private boolean MIXIN()
    {
      if (saved(MIXIN)) return reuse();
      if (!next("mixin")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  NATIVE = "native" spacing ;
  //=====================================================================
  private boolean NATIVE()
    {
      if (saved(NATIVE)) return reuse();
      if (!next("native")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  NEW = "new" spacing ;
  //=====================================================================
  private boolean NEW()
    {
      if (saved(NEW)) return reuse();
      if (!next("new")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  NULL = "null" spacing ;
  //=====================================================================
  private boolean NULL()
    {
      if (saved(NULL)) return reuse();
      if (!next("null")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  NUMBER = "number" spacing ;
  //=====================================================================
  private boolean NUMBER()
    {
      if (saved(NUMBER)) return reuse();
      if (!next("number")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  OVERRIDE = "override" spacing ;
  //=====================================================================
  private boolean OVERRIDE()
    {
      if (saved(OVERRIDE)) return reuse();
      if (!next("override")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  RETURN = "return" spacing ;
  //=====================================================================
  private boolean RETURN()
    {
      if (saved(RETURN)) return reuse();
      if (!next("return")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  STATIC = "static" spacing ;
  //=====================================================================
  private boolean STATIC()
    {
      if (saved(STATIC)) return reuse();
      if (!next("static")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  STRING = "string" spacing ;
  //=====================================================================
  private boolean STRING()
    {
      if (saved(STRING)) return reuse();
      if (!next("string")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  SUPER = "super" spacing ;
  //=====================================================================
  private boolean SUPER()
    {
      if (saved(SUPER)) return reuse();
      if (!next("super")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  SWITCH = "switch" spacing ;
  //=====================================================================
  private boolean SWITCH()
    {
      if (saved(SWITCH)) return reuse();
      if (!next("switch")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  THIS = "this" spacing ;
  //=====================================================================
  private boolean THIS()
    {
      if (saved(THIS)) return reuse();
      if (!next("this")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  THROW = "throw" spacing ;
  //=====================================================================
  private boolean THROW()
    {
      if (saved(THROW)) return reuse();
      if (!next("throw")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  TRUE = "true" spacing ;
  //=====================================================================
  private boolean TRUE()
    {
      if (saved(TRUE)) return reuse();
      if (!next("true")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  TRY = "try" spacing ;
  //=====================================================================
  private boolean TRY()
    {
      if (saved(TRY)) return reuse();
      if (!next("try")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  TYPEOF = "typeof" spacing ;
  //=====================================================================
  private boolean TYPEOF()
    {
      if (saved(TYPEOF)) return reuse();
      if (!next("typeof")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  UNDEFINED = "undefined" spacing ;
  //=====================================================================
  private boolean UNDEFINED()
    {
      if (saved(UNDEFINED)) return reuse();
      if (!next("undefined")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  VAR = "var" spacing ;
  //=====================================================================
  private boolean VAR()
    {
      if (saved(VAR)) return reuse();
      if (!next("var")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  VARIANT = "variant" spacing ;
  //=====================================================================
  private boolean VARIANT()
    {
      if (saved(VARIANT)) return reuse();
      if (!next("variant")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  VOID = "void" spacing ;
  //=====================================================================
  private boolean VOID()
    {
      if (saved(VOID)) return reuse();
      if (!next("void")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  WHILE = "while" spacing ;
  //=====================================================================
  private boolean WHILE()
    {
      if (saved(WHILE)) return reuse();
      if (!next("while")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  BLTCONFAKE = "__fake__" spacing ;
  //=====================================================================
  private boolean BLTCONFAKE()
    {
      if (saved(BLTCONFAKE)) return reuse();
      if (!next("__fake__")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  BLTCONNOCONVERT = "__noconvert__" spacing ;
  //=====================================================================
  private boolean BLTCONNOCONVERT()
    {
      if (saved(BLTCONNOCONVERT)) return reuse();
      if (!next("__noconvert__")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  BLTCONPURE = "__pure__" spacing ;
  //=====================================================================
  private boolean BLTCONPURE()
    {
      if (saved(BLTCONPURE)) return reuse();
      if (!next("__pure__")) return reject();
      spacing();
      return accept();
    }
  
  //=====================================================================
  //  BLTCONREADONLY = "__readonly__" spacing ;
  //=====================================================================
  private boolean BLTCONREADONLY()
    {
      if (saved(BLTCONREADONLY)) return reuse();
      if (!next("__readonly__")) return reject();
      spacing();
      return accept();
    }
  
  //=======================================================================
  //
  //  Cache objects
  //
  //=======================================================================
  
  final Cache programFile = new Cache("programFile","programFile");
  final Cache importStatement = new Cache("importStatement","importStatement");
  final Cache classDefinition = new Cache("classDefinition","classDefinition");
  final Cache oClassModifiers = new Cache("oClassModifiers","oClassModifiers");
  final Cache oClassDef = new Cache("oClassDef","oClassDef");
  final Cache oInterfaceDef = new Cache("oInterfaceDef","oInterfaceDef");
  final Cache oMixinDef = new Cache("oMixinDef","oMixinDef");
  final Cache memberDefinition = new Cache("memberDefinition","memberDefinition");
  final Cache oMemberDefinitionModifiers = new Cache("oMemberDefinitionModifiers","oMemberDefinitionModifiers");
  final Cache functionDefinition = new Cache("functionDefinition","functionDefinition");
  final Cache formalTypeArguments = new Cache("formalTypeArguments","formalTypeArguments");
  final Cache actualTypeArguments = new Cache("actualTypeArguments","actualTypeArguments");
  final Cache typeDeclaration = new Cache("typeDeclaration","typeDeclaration");
  final Cache typeDeclarationNoArrayNoVoid = new Cache("typeDeclarationNoArrayNoVoid","typeDeclarationNoArrayNoVoid");
  final Cache nullableTypeDeclaration = new Cache("nullableTypeDeclaration","nullableTypeDeclaration");
  final Cache primaryTypeDeclaration = new Cache("primaryTypeDeclaration","primaryTypeDeclaration");
  final Cache objectTypeDeclaration = new Cache("objectTypeDeclaration","objectTypeDeclaration");
  final Cache lightFunctionTypeDeclaration = new Cache("lightFunctionTypeDeclaration","lightFunctionTypeDeclaration");
  final Cache functionTypeDeclaration = new Cache("functionTypeDeclaration","functionTypeDeclaration");
  final Cache initializeBlock = new Cache("initializeBlock","initializeBlock");
  final Cache block = new Cache("block","block");
  final Cache statement = new Cache("statement","statement");
  final Cache assignExpr = new Cache("assignExpr","assignExpr");
  final Cache tryStatement = new Cache("tryStatement","tryStatement");
  final Cache logStatement = new Cache("logStatement","logStatement");
  final Cache breakStatement = new Cache("breakStatement","breakStatement");
  final Cache switchStatement = new Cache("switchStatement","switchStatement");
  final Cache continueStatement = new Cache("continueStatement","continueStatement");
  final Cache forStatement = new Cache("forStatement","forStatement");
  final Cache doWhileStatement = new Cache("doWhileStatement","doWhileStatement");
  final Cache functionStatement = new Cache("functionStatement","functionStatement");
  final Cache throwStatement = new Cache("throwStatement","throwStatement");
  final Cache returnStatement = new Cache("returnStatement","returnStatement");
  final Cache variableStatement = new Cache("variableStatement","variableStatement");
  final Cache deleteStatement = new Cache("deleteStatement","deleteStatement");
  final Cache debuggerStatement = new Cache("debuggerStatement","debuggerStatement");
  final Cache assertStatement = new Cache("assertStatement","assertStatement");
  final Cache ifStatement = new Cache("ifStatement","ifStatement");
  final Cache whileStatement = new Cache("whileStatement","whileStatement");
  final Cache constructorInvocationStatement = new Cache("constructorInvocationStatement","constructorInvocationStatement");
  final Cache expr = new Cache("expr","expr");
  final Cache ident = new Cache("ident","ident");
  final Cache nullLiteral = new Cache("nullLiteral","nullLiteral");
  final Cache arrayLiteral = new Cache("arrayLiteral","arrayLiteral");
  final Cache hashLiteral = new Cache("hashLiteral","hashLiteral");
  final Cache functionArgumentsExpr = new Cache("functionArgumentsExpr","functionArgumentsExpr");
  final Cache argsExpr = new Cache("argsExpr","argsExpr");
  final Cache string = new Cache("string","string");
  final Cache doubleQuoted = new Cache("doubleQuoted","doubleQuoted");
  final Cache singleQuoted = new Cache("singleQuoted","singleQuoted");
  final Cache regexp = new Cache("regexp","regexp");
  final Cache numberLiteral = new Cache("numberLiteral","numberLiteral");
  final Cache decimalIntegerLiteral = new Cache("decimalIntegerLiteral","decimalIntegerLiteral");
  final Cache exponentPart = new Cache("exponentPart","exponentPart");
  final Cache numberLiteral2 = new Cache("numberLiteral2","numberLiteral2");
  final Cache integerLiteral = new Cache("integerLiteral","integerLiteral");
  final Cache multilineComment = new Cache("multilineComment","multilineComment");
  final Cache singlelineComment = new Cache("singlelineComment","singlelineComment");
  final Cache spacing = new Cache("spacing","spacing");
  final Cache space = new Cache("space","space");
  final Cache NOT = new Cache("NOT","NOT");
  final Cache NOTEQ = new Cache("NOTEQ","NOTEQ");
  final Cache SUR = new Cache("SUR","SUR");
  final Cache SUREEQ = new Cache("SUREEQ","SUREEQ");
  final Cache AND = new Cache("AND","AND");
  final Cache BITAND = new Cache("BITAND","BITAND");
  final Cache BITANDEQ = new Cache("BITANDEQ","BITANDEQ");
  final Cache LPAR = new Cache("LPAR","LPAR");
  final Cache RPAR = new Cache("RPAR","RPAR");
  final Cache MUL = new Cache("MUL","MUL");
  final Cache MULEQ = new Cache("MULEQ","MULEQ");
  final Cache ADD = new Cache("ADD","ADD");
  final Cache INC = new Cache("INC","INC");
  final Cache ADDEQ = new Cache("ADDEQ","ADDEQ");
  final Cache COMMA = new Cache("COMMA","COMMA");
  final Cache SUB = new Cache("SUB","SUB");
  final Cache DEC = new Cache("DEC","DEC");
  final Cache SUBEQ = new Cache("SUBEQ","SUBEQ");
  final Cache ARROW = new Cache("ARROW","ARROW");
  final Cache DOT = new Cache("DOT","DOT");
  final Cache ARGS = new Cache("ARGS","ARGS");
  final Cache DIV = new Cache("DIV","DIV");
  final Cache DIVEQ = new Cache("DIVEQ","DIVEQ");
  final Cache COLON = new Cache("COLON","COLON");
  final Cache SEMI = new Cache("SEMI","SEMI");
  final Cache LT = new Cache("LT","LT");
  final Cache LSHIFT = new Cache("LSHIFT","LSHIFT");
  final Cache LSHIFTEQ = new Cache("LSHIFTEQ","LSHIFTEQ");
  final Cache LTEQ = new Cache("LTEQ","LTEQ");
  final Cache ASSIGN = new Cache("ASSIGN","ASSIGN");
  final Cache EQ = new Cache("EQ","EQ");
  final Cache GT = new Cache("GT","GT");
  final Cache GTEQ = new Cache("GTEQ","GTEQ");
  final Cache COND = new Cache("COND","COND");
  final Cache LBRA = new Cache("LBRA","LBRA");
  final Cache RBRA = new Cache("RBRA","RBRA");
  final Cache XOR = new Cache("XOR","XOR");
  final Cache XOREQ = new Cache("XOREQ","XOREQ");
  final Cache LWING = new Cache("LWING","LWING");
  final Cache BITOR = new Cache("BITOR","BITOR");
  final Cache BITOREQ = new Cache("BITOREQ","BITOREQ");
  final Cache OR = new Cache("OR","OR");
  final Cache RWING = new Cache("RWING","RWING");
  final Cache MAYBEUNDEFINED = new Cache("MAYBEUNDEFINED","MAYBEUNDEFINED");
  final Cache NULLABLE = new Cache("NULLABLE","NULLABLE");
  final Cache ABSTRACT = new Cache("ABSTRACT","ABSTRACT");
  final Cache AS = new Cache("AS","AS");
  final Cache ASSERT = new Cache("ASSERT","ASSERT");
  final Cache BOOLEAN = new Cache("BOOLEAN","BOOLEAN");
  final Cache BREAK = new Cache("BREAK","BREAK");
  final Cache CASE = new Cache("CASE","CASE");
  final Cache CATCH = new Cache("CATCH","CATCH");
  final Cache CLASS = new Cache("CLASS","CLASS");
  final Cache CONST = new Cache("CONST","CONST");
  final Cache CONSTRUCTOR = new Cache("CONSTRUCTOR","CONSTRUCTOR");
  final Cache CONTINUE = new Cache("CONTINUE","CONTINUE");
  final Cache DEBUGGER = new Cache("DEBUGGER","DEBUGGER");
  final Cache DEFAULT = new Cache("DEFAULT","DEFAULT");
  final Cache DELETE = new Cache("DELETE","DELETE");
  final Cache DO = new Cache("DO","DO");
  final Cache ELSE = new Cache("ELSE","ELSE");
  final Cache EXTENDS = new Cache("EXTENDS","EXTENDS");
  final Cache FALSE = new Cache("FALSE","FALSE");
  final Cache FINAL = new Cache("FINAL","FINAL");
  final Cache FINALLY = new Cache("FINALLY","FINALLY");
  final Cache FOR = new Cache("FOR","FOR");
  final Cache FROM = new Cache("FROM","FROM");
  final Cache FUNCTION = new Cache("FUNCTION","FUNCTION");
  final Cache IF = new Cache("IF","IF");
  final Cache IMPLEMENTS = new Cache("IMPLEMENTS","IMPLEMENTS");
  final Cache IMPORT = new Cache("IMPORT","IMPORT");
  final Cache IN = new Cache("IN","IN");
  final Cache INLINE = new Cache("INLINE","INLINE");
  final Cache INSTANCEOF = new Cache("INSTANCEOF","INSTANCEOF");
  final Cache INT = new Cache("INT","INT");
  final Cache INTERFACE = new Cache("INTERFACE","INTERFACE");
  final Cache INTO = new Cache("INTO","INTO");
  final Cache LOG = new Cache("LOG","LOG");
  final Cache MIXIN = new Cache("MIXIN","MIXIN");
  final Cache NATIVE = new Cache("NATIVE","NATIVE");
  final Cache NEW = new Cache("NEW","NEW");
  final Cache NULL = new Cache("NULL","NULL");
  final Cache NUMBER = new Cache("NUMBER","NUMBER");
  final Cache OVERRIDE = new Cache("OVERRIDE","OVERRIDE");
  final Cache RETURN = new Cache("RETURN","RETURN");
  final Cache STATIC = new Cache("STATIC","STATIC");
  final Cache STRING = new Cache("STRING","STRING");
  final Cache SUPER = new Cache("SUPER","SUPER");
  final Cache SWITCH = new Cache("SWITCH","SWITCH");
  final Cache THIS = new Cache("THIS","THIS");
  final Cache THROW = new Cache("THROW","THROW");
  final Cache TRUE = new Cache("TRUE","TRUE");
  final Cache TRY = new Cache("TRY","TRY");
  final Cache TYPEOF = new Cache("TYPEOF","TYPEOF");
  final Cache UNDEFINED = new Cache("UNDEFINED","UNDEFINED");
  final Cache VAR = new Cache("VAR","VAR");
  final Cache VARIANT = new Cache("VARIANT","VARIANT");
  final Cache VOID = new Cache("VOID","VOID");
  final Cache WHILE = new Cache("WHILE","WHILE");
  final Cache BLTCONFAKE = new Cache("BLTCONFAKE","BLTCONFAKE");
  final Cache BLTCONNOCONVERT = new Cache("BLTCONNOCONVERT","BLTCONNOCONVERT");
  final Cache BLTCONPURE = new Cache("BLTCONPURE","BLTCONPURE");
  final Cache BLTCONREADONLY = new Cache("BLTCONREADONLY","BLTCONREADONLY");
  
  final Cache importStatement_0 = new Cache("importStatement_0"); // ident (COMMA ident)* FROM
  final Cache importStatement_1 = new Cache("importStatement_1"); // INTO ident
  final Cache importStatement_2 = new Cache("importStatement_2"); // COMMA ident
  final Cache oClassDef_0 = new Cache("oClassDef_0"); // EXTENDS objectTypeDeclaration
  final Cache oClassDef_1 = new Cache("oClassDef_1"); // IMPLEMENTS objectTypeDeclaration (COMMA objectTypeDeclaration)*
  final Cache oClassDef_2 = new Cache("oClassDef_2"); // COMMA objectTypeDeclaration
  final Cache memberDefinition_0 = new Cache("memberDefinition_0"); // oMemberDefinitionModifiers* CONST ident (COLON typeDeclaration)? (EQ assignExpr)? SEMI
  final Cache memberDefinition_1 = new Cache("memberDefinition_1"); // oMemberDefinitionModifiers* FUNCTION functionDefinition
  final Cache memberDefinition_2 = new Cache("memberDefinition_2"); // oMemberDefinitionModifiers* VAR ident (COLON typeDeclaration)? (EQ assignExpr)? SEMI
  final Cache memberDefinition_3 = new Cache("memberDefinition_3"); // COLON typeDeclaration
  final Cache memberDefinition_4 = new Cache("memberDefinition_4"); // EQ assignExpr
  final Cache functionDefinition_0 = new Cache("functionDefinition_0"); // CONSTRUCTOR formalTypeArguments LPAR functionArgumentsExpr LWING initializeBlock
  final Cache functionDefinition_1 = new Cache("functionDefinition_1"); // ident formalTypeArguments LPAR functionArgumentsExpr COLON typeDeclaration (SEMI / LWING block)
  final Cache functionDefinition_2 = new Cache("functionDefinition_2"); // LWING block
  final Cache formalTypeArguments_0 = new Cache("formalTypeArguments_0"); // DOT LT ident (COMMA ident)* GT
  final Cache actualTypeArguments_0 = new Cache("actualTypeArguments_0"); // DOT LT typeDeclaration (COMMA typeDeclaration)* GT
  final Cache actualTypeArguments_1 = new Cache("actualTypeArguments_1"); // COMMA typeDeclaration
  final Cache typeDeclaration_0 = new Cache("typeDeclaration_0"); // typeDeclarationNoArrayNoVoid (LBRA RBRA)?
  final Cache typeDeclaration_1 = new Cache("typeDeclaration_1"); // LBRA RBRA
  final Cache typeDeclarationNoArrayNoVoid_0 = new Cache("typeDeclarationNoArrayNoVoid_0"); // NULLABLE nullableTypeDeclaration
  final Cache primaryTypeDeclaration_0 = new Cache("primaryTypeDeclaration_0"); // LPAR lightFunctionTypeDeclaration
  final Cache primaryTypeDeclaration_1 = new Cache("primaryTypeDeclaration_1"); // FUNCTION functionTypeDeclaration
  final Cache objectTypeDeclaration_0 = new Cache("objectTypeDeclaration_0"); // (SUPER / ident) actualTypeArguments
  final Cache objectTypeDeclaration_1 = new Cache("objectTypeDeclaration_1"); // DOT ident
  final Cache lightFunctionTypeDeclaration_0 = new Cache("lightFunctionTypeDeclaration_0"); // COMMA ARGS? typeDeclaration
  final Cache functionTypeDeclaration_0 = new Cache("functionTypeDeclaration_0"); // ident? LPAR (ARGS ident? COLON typeDeclaration RPAR)? COLON typeDeclaration
  final Cache functionTypeDeclaration_1 = new Cache("functionTypeDeclaration_1"); // ident? LPAR (ident? COLON typeDeclaration) (COMMA ident? COLON typeDeclaration)* COMMA (ARGS ident? COLON typeDeclaration RPAR)? COLON typeDeclaration
  final Cache functionTypeDeclaration_2 = new Cache("functionTypeDeclaration_2"); // ARGS ident? COLON typeDeclaration RPAR
  final Cache functionTypeDeclaration_3 = new Cache("functionTypeDeclaration_3"); // COMMA ident? COLON typeDeclaration
  final Cache initializeBlock_0 = new Cache("initializeBlock_0"); // block?
  final Cache statement_0 = new Cache("statement_0"); // VAR variableStatement
  final Cache statement_1 = new Cache("statement_1"); // IF ifStatement
  final Cache statement_2 = new Cache("statement_2"); // CONTINUE continueStatement
  final Cache statement_3 = new Cache("statement_3"); // BREAK breakStatement
  final Cache statement_4 = new Cache("statement_4"); // RETURN returnStatement
  final Cache statement_5 = new Cache("statement_5"); // THROW throwStatement
  final Cache statement_6 = new Cache("statement_6"); // TRY tryStatement
  final Cache statement_7 = new Cache("statement_7"); // ASSERT assertStatement
  final Cache statement_8 = new Cache("statement_8"); // LOG logStatement
  final Cache statement_9 = new Cache("statement_9"); // DELETE deleteStatement
  final Cache statement_10 = new Cache("statement_10"); // DEBUGGER debuggerStatement
  final Cache statement_11 = new Cache("statement_11"); // FUNCTION functionStatement
  final Cache statement_12 = new Cache("statement_12"); // expr SEMI
  final Cache statement_13 = new Cache("statement_13"); // (ident SEMI)? DO doWhileStatement
  final Cache statement_14 = new Cache("statement_14"); // (ident SEMI)? WHILE whileStatement
  final Cache statement_15 = new Cache("statement_15"); // (ident SEMI)? FOR forStatement
  final Cache statement_16 = new Cache("statement_16"); // (ident SEMI)? SWITCH switchStatement
  final Cache statement_17 = new Cache("statement_17"); // ident SEMI
  final Cache ident_0 = new Cache("ident_0"); // [a-z] / [A-Z] / "_" / [0-9]
  final Cache nullLiteral_0 = new Cache("nullLiteral_0"); // ":" typeDeclaration
  final Cache arrayLiteral_0 = new Cache("arrayLiteral_0"); // assignExpr ("," assignExpr)*
  final Cache arrayLiteral_1 = new Cache("arrayLiteral_1"); // "," assignExpr
  final Cache hashLiteral_0 = new Cache("hashLiteral_0"); // (ident / numberLiteral / string) COLON assignExpr (COMMA (ident / numberLiteral / string) COLON assignExpr)*
  final Cache hashLiteral_1 = new Cache("hashLiteral_1"); // COMMA (ident / numberLiteral / string) COLON assignExpr
  final Cache functionArgumentsExpr_0 = new Cache("functionArgumentsExpr_0"); // (ARGS ident / ident)? (COLON typeDeclaration)? (COMMA (ARGS ident / ident)? (COLON typeDeclaration)?)* RPAR
  final Cache functionArgumentsExpr_1 = new Cache("functionArgumentsExpr_1"); // ARGS ident / ident
  final Cache functionArgumentsExpr_2 = new Cache("functionArgumentsExpr_2"); // COMMA (ARGS ident / ident)? (COLON typeDeclaration)?
  final Cache functionArgumentsExpr_3 = new Cache("functionArgumentsExpr_3"); // ARGS ident
  final Cache argsExpr_0 = new Cache("argsExpr_0"); // assignExpr (COMMA assignExpr)* RPAR
  final Cache argsExpr_1 = new Cache("argsExpr_1"); // COMMA assignExpr
  final Cache string_0 = new Cache("string_0"); // doubleQuoted spacing?
  final Cache string_1 = new Cache("string_1"); // singleQuoted spacing?
  final Cache doubleQuoted_0 = new Cache("doubleQuoted_0"); // "\" _ (!""" !"\" _)*
  final Cache doubleQuoted_1 = new Cache("doubleQuoted_1"); // !""" !"\" _
  final Cache singleQuoted_0 = new Cache("singleQuoted_0"); // !"'" !"\" _
  final Cache singleQuoted_1 = new Cache("singleQuoted_1"); // "\" _ (!"'" !"\" _)*
  final Cache regexp_0 = new Cache("regexp_0"); // !"/" !"\" _
  final Cache regexp_1 = new Cache("regexp_1"); // "\" _ (!"/" !"\" _)*
  final Cache regexp_2 = new Cache("regexp_2"); // "m" / "g" / "i"
  final Cache decimalIntegerLiteral_0 = new Cache("decimalIntegerLiteral_0"); // [1-9] [0-9]*
  final Cache numberLiteral2_0 = new Cache("numberLiteral2_0"); // decimalIntegerLiteral ("." [0-9]*)? exponentPart?
  final Cache numberLiteral2_1 = new Cache("numberLiteral2_1"); // "." [0-9]+ exponentPart?
  final Cache numberLiteral2_2 = new Cache("numberLiteral2_2"); // "." [0-9]*
  final Cache integerLiteral_0 = new Cache("integerLiteral_0"); // "0" [xX] [0-9a-fA-F]+
  final Cache multilineComment_0 = new Cache("multilineComment_0"); // !"*/" _
  final Cache singlelineComment_0 = new Cache("singlelineComment_0"); // !"\n" !"\r" _
  final Cache spacing_0 = new Cache("spacing_0"); // space / multilineComment / singlelineComment
  
  //-------------------------------------------------------------------
  //  List of Cache objects
  //-------------------------------------------------------------------
  
  Cache[] cacheList =
  {
    programFile,importStatement,classDefinition,oClassModifiers,
    oClassDef,oInterfaceDef,oMixinDef,memberDefinition,
    oMemberDefinitionModifiers,functionDefinition,formalTypeArguments,
    actualTypeArguments,typeDeclaration,typeDeclarationNoArrayNoVoid,
    nullableTypeDeclaration,primaryTypeDeclaration,
    objectTypeDeclaration,lightFunctionTypeDeclaration,
    functionTypeDeclaration,initializeBlock,block,statement,
    assignExpr,tryStatement,logStatement,breakStatement,
    switchStatement,continueStatement,forStatement,doWhileStatement,
    functionStatement,throwStatement,returnStatement,
    variableStatement,deleteStatement,debuggerStatement,
    assertStatement,ifStatement,whileStatement,
    constructorInvocationStatement,expr,ident,nullLiteral,
    arrayLiteral,hashLiteral,functionArgumentsExpr,argsExpr,string,
    doubleQuoted,singleQuoted,regexp,numberLiteral,
    decimalIntegerLiteral,exponentPart,numberLiteral2,integerLiteral,
    multilineComment,singlelineComment,spacing,space,NOT,NOTEQ,SUR,
    SUREEQ,AND,BITAND,BITANDEQ,LPAR,RPAR,MUL,MULEQ,ADD,INC,ADDEQ,
    COMMA,SUB,DEC,SUBEQ,ARROW,DOT,ARGS,DIV,DIVEQ,COLON,SEMI,LT,LSHIFT,
    LSHIFTEQ,LTEQ,ASSIGN,EQ,GT,GTEQ,COND,LBRA,RBRA,XOR,XOREQ,LWING,
    BITOR,BITOREQ,OR,RWING,MAYBEUNDEFINED,NULLABLE,ABSTRACT,AS,ASSERT,
    BOOLEAN,BREAK,CASE,CATCH,CLASS,CONST,CONSTRUCTOR,CONTINUE,
    DEBUGGER,DEFAULT,DELETE,DO,ELSE,EXTENDS,FALSE,FINAL,FINALLY,FOR,
    FROM,FUNCTION,IF,IMPLEMENTS,IMPORT,IN,INLINE,INSTANCEOF,INT,
    INTERFACE,INTO,LOG,MIXIN,NATIVE,NEW,NULL,NUMBER,OVERRIDE,RETURN,
    STATIC,STRING,SUPER,SWITCH,THIS,THROW,TRUE,TRY,TYPEOF,UNDEFINED,
    VAR,VARIANT,VOID,WHILE,BLTCONFAKE,BLTCONNOCONVERT,BLTCONPURE,
    BLTCONREADONLY,importStatement_0,importStatement_1,
    importStatement_2,oClassDef_0,oClassDef_1,oClassDef_2,
    memberDefinition_0,memberDefinition_1,memberDefinition_2,
    memberDefinition_3,memberDefinition_4,functionDefinition_0,
    functionDefinition_1,functionDefinition_2,formalTypeArguments_0,
    actualTypeArguments_0,actualTypeArguments_1,typeDeclaration_0,
    typeDeclaration_1,typeDeclarationNoArrayNoVoid_0,
    primaryTypeDeclaration_0,primaryTypeDeclaration_1,
    objectTypeDeclaration_0,objectTypeDeclaration_1,
    lightFunctionTypeDeclaration_0,functionTypeDeclaration_0,
    functionTypeDeclaration_1,functionTypeDeclaration_2,
    functionTypeDeclaration_3,initializeBlock_0,statement_0,
    statement_1,statement_2,statement_3,statement_4,statement_5,
    statement_6,statement_7,statement_8,statement_9,statement_10,
    statement_11,statement_12,statement_13,statement_14,statement_15,
    statement_16,statement_17,ident_0,nullLiteral_0,arrayLiteral_0,
    arrayLiteral_1,hashLiteral_0,hashLiteral_1,
    functionArgumentsExpr_0,functionArgumentsExpr_1,
    functionArgumentsExpr_2,functionArgumentsExpr_3,argsExpr_0,
    argsExpr_1,string_0,string_1,doubleQuoted_0,doubleQuoted_1,
    singleQuoted_0,singleQuoted_1,regexp_0,regexp_1,regexp_2,
    decimalIntegerLiteral_0,numberLiteral2_0,numberLiteral2_1,
    numberLiteral2_2,integerLiteral_0,multilineComment_0,
    singlelineComment_0,spacing_0
  };
}
