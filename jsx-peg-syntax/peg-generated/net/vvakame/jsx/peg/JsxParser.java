//=========================================================================
//
//  This file was generated by Mouse 1.5 at 2012-09-06 05:33:54 GMT
//  from grammar
//    '/Users/vvakame/Dropbox/work/jsx-plugin-for-eclipse/jsx-peg-syntax/sr
//    c/main/peg/JSX.peg'.
//
//=========================================================================

package net.vvakame.jsx.peg;

import mouse.runtime.Source;

public class JsxParser extends mouse.runtime.ParserMemo {
	final JsxSemantics sem;

	// =======================================================================
	//
	// Initialization
	//
	// =======================================================================
	// -------------------------------------------------------------------
	// Constructor
	// -------------------------------------------------------------------
	public JsxParser() {
		sem = new JsxSemantics();
		sem.rule = this;
		super.sem = sem;
		caches = cacheList;
	}

	// -------------------------------------------------------------------
	// Run the parser
	// -------------------------------------------------------------------
	public boolean parse(Source src) {
		super.init(src);
		sem.init();
		if (programFile())
			return true;
		return failure();
	}

	// -------------------------------------------------------------------
	// Get semantics
	// -------------------------------------------------------------------
	public JsxSemantics semantics() {
		return sem;
	}

	// =======================================================================
	//
	// Parsing procedures
	//
	// =======================================================================
	// =====================================================================
	// programFile = spacing? importStatement* classDefinition* !_
	// {programFile} ;
	// =====================================================================
	private boolean programFile() {
		if (saved(programFile))
			return reuse();
		spacing();
		while (importStatement())
			;
		while (classDefinition())
			;
		if (!aheadNot())
			return reject();
		sem.programFile();
		return accept();
	}

	// =====================================================================
	// importStatement = IMPORT (ident (COMMA ident)* FROM)? string (INTO
	// ident)? SEMI {importStatement} ;
	// =====================================================================
	private boolean importStatement() {
		if (saved(importStatement))
			return reuse();
		if (!IMPORT())
			return reject();
		importStatement_0();
		if (!string())
			return reject();
		importStatement_1();
		if (!SEMI())
			return reject();
		sem.importStatement();
		return accept();
	}

	// -------------------------------------------------------------------
	// importStatement_0 = ident (COMMA ident)* FROM
	// -------------------------------------------------------------------
	private boolean importStatement_0() {
		if (savedInner(importStatement_0))
			return reuseInner();
		if (!ident())
			return rejectInner();
		while (importStatement_2())
			;
		if (!FROM())
			return rejectInner();
		return acceptInner();
	}

	// -------------------------------------------------------------------
	// importStatement_1 = INTO ident
	// -------------------------------------------------------------------
	private boolean importStatement_1() {
		if (savedInner(importStatement_1))
			return reuseInner();
		if (!INTO())
			return rejectInner();
		if (!ident())
			return rejectInner();
		return acceptInner();
	}

	// -------------------------------------------------------------------
	// importStatement_2 = COMMA ident
	// -------------------------------------------------------------------
	private boolean importStatement_2() {
		if (savedInner(importStatement_2))
			return reuseInner();
		if (!COMMA())
			return rejectInner();
		if (!ident())
			return rejectInner();
		return acceptInner();
	}

	// =====================================================================
	// classDefinition = oClassModifiers* (oClassDef / oInterfaceDef /
	// oMixinDef) spacing? ;
	// =====================================================================
	private boolean classDefinition() {
		if (saved(classDefinition))
			return reuse();
		while (oClassModifiers())
			;
		if (!oClassDef() && !oInterfaceDef() && !oMixinDef())
			return reject();
		spacing();
		return accept();
	}

	// =====================================================================
	// oClassModifiers = ABSTRACT / FINAL / NATIVE / BLTCONFAKE ;
	// =====================================================================
	private boolean oClassModifiers() {
		if (saved(oClassModifiers))
			return reuse();
		if (ABSTRACT())
			return accept();
		if (FINAL())
			return accept();
		if (NATIVE())
			return accept();
		if (BLTCONFAKE())
			return accept();
		return reject();
	}

	// =====================================================================
	// oClassDef = CLASS IDENT formalTypeArguments? (EXTENDS
	// objectTypeDeclaration)? (IMPLEMENTS objectTypeDeclaration (COMMA
	// objectTypeDeclaration)*)? LBRA memberDefinition* RBRA ;
	// =====================================================================
	private boolean oClassDef() {
		if (saved(oClassDef))
			return reuse();
		if (!CLASS())
			return reject();
		if (!IDENT())
			return reject();
		formalTypeArguments();
		oClassDef_0();
		oClassDef_1();
		if (!LBRA())
			return reject();
		while (memberDefinition())
			;
		if (!RBRA())
			return reject();
		return accept();
	}

	// -------------------------------------------------------------------
	// oClassDef_0 = EXTENDS objectTypeDeclaration
	// -------------------------------------------------------------------
	private boolean oClassDef_0() {
		if (savedInner(oClassDef_0))
			return reuseInner();
		if (!EXTENDS())
			return rejectInner();
		if (!objectTypeDeclaration())
			return rejectInner();
		return acceptInner();
	}

	// -------------------------------------------------------------------
	// oClassDef_1 = IMPLEMENTS objectTypeDeclaration (COMMA
	// objectTypeDeclaration)*
	// -------------------------------------------------------------------
	private boolean oClassDef_1() {
		if (savedInner(oClassDef_1))
			return reuseInner();
		if (!IMPLEMENTS())
			return rejectInner();
		if (!objectTypeDeclaration())
			return rejectInner();
		while (oClassDef_2())
			;
		return acceptInner();
	}

	// -------------------------------------------------------------------
	// oClassDef_2 = COMMA objectTypeDeclaration
	// -------------------------------------------------------------------
	private boolean oClassDef_2() {
		if (savedInner(oClassDef_2))
			return reuseInner();
		if (!COMMA())
			return rejectInner();
		if (!objectTypeDeclaration())
			return rejectInner();
		return acceptInner();
	}

	// =====================================================================
	// oInterfaceDef = INTERFACE IDENT formalTypeArguments? (IMPLEMENTS
	// objectTypeDeclaration (COMMA objectTypeDeclaration)*)? LBRA
	// memberDefinition* RBRA ;
	// =====================================================================
	private boolean oInterfaceDef() {
		if (saved(oInterfaceDef))
			return reuse();
		if (!INTERFACE())
			return reject();
		if (!IDENT())
			return reject();
		formalTypeArguments();
		oClassDef_1();
		if (!LBRA())
			return reject();
		while (memberDefinition())
			;
		if (!RBRA())
			return reject();
		return accept();
	}

	// =====================================================================
	// oMixinDef = MIXIN IDENT formalTypeArguments? LBRA memberDefinition*
	// RBRA ;
	// =====================================================================
	private boolean oMixinDef() {
		if (saved(oMixinDef))
			return reuse();
		if (!MIXIN())
			return reject();
		if (!IDENT())
			return reject();
		formalTypeArguments();
		if (!LBRA())
			return reject();
		while (memberDefinition())
			;
		if (!RBRA())
			return reject();
		return accept();
	}

	// =====================================================================
	// objectTypeDeclaration = "a" ;
	// =====================================================================
	private boolean objectTypeDeclaration() {
		if (saved(objectTypeDeclaration))
			return reuse();
		if (!next('a'))
			return reject();
		return accept();
	}

	// =====================================================================
	// memberDefinition = "a" ;
	// =====================================================================
	private boolean memberDefinition() {
		if (saved(memberDefinition))
			return reuse();
		if (!next('a'))
			return reject();
		return accept();
	}

	// =====================================================================
	// IDENT = "a" ;
	// =====================================================================
	private boolean IDENT() {
		if (saved(IDENT))
			return reuse();
		if (!next('a'))
			return reject();
		return accept();
	}

	// =====================================================================
	// formalTypeArguments = "a" ;
	// =====================================================================
	private boolean formalTypeArguments() {
		if (saved(formalTypeArguments))
			return reuse();
		if (!next('a'))
			return reject();
		return accept();
	}

	// =====================================================================
	// ident = ([a-z] / [A-Z] / "_") ([a-z] / [A-Z] / "_" / [0-9])*
	// spacing ;
	// =====================================================================
	private boolean ident() {
		if (saved(ident))
			return reuse();
		if (!nextIn('a', 'z') && !nextIn('A', 'Z') && !next('_'))
			return reject();
		while (ident_0())
			;
		if (!spacing())
			return reject();
		return accept();
	}

	// -------------------------------------------------------------------
	// ident_0 = [a-z] / [A-Z] / "_" / [0-9]
	// -------------------------------------------------------------------
	private boolean ident_0() {
		if (savedInner(ident_0))
			return reuseInner();
		if (nextIn('a', 'z'))
			return acceptInner();
		if (nextIn('A', 'Z'))
			return acceptInner();
		if (next('_'))
			return acceptInner();
		if (nextIn('0', '9'))
			return acceptInner();
		return rejectInner();
	}

	// =====================================================================
	// string = doubleQuoted / singleQuoted ;
	// =====================================================================
	private boolean string() {
		if (saved(string))
			return reuse();
		if (doubleQuoted())
			return accept();
		if (singleQuoted())
			return accept();
		return reject();
	}

	// =====================================================================
	// doubleQuoted = """ ^["\]* ("\" _ (!""" !"\" _)*)* """ ;
	// =====================================================================
	private boolean doubleQuoted() {
		if (saved(doubleQuoted))
			return reuse();
		if (!next('"'))
			return reject();
		while (nextNotIn("\"\\"))
			;
		while (doubleQuoted_0())
			;
		if (!next('"'))
			return reject();
		return accept();
	}

	// -------------------------------------------------------------------
	// doubleQuoted_0 = "\" _ (!""" !"\" _)*
	// -------------------------------------------------------------------
	private boolean doubleQuoted_0() {
		if (savedInner(doubleQuoted_0))
			return reuseInner();
		if (!next('\\'))
			return rejectInner();
		if (!next())
			return rejectInner();
		while (doubleQuoted_1())
			;
		return acceptInner();
	}

	// -------------------------------------------------------------------
	// doubleQuoted_1 = !""" !"\" _
	// -------------------------------------------------------------------
	private boolean doubleQuoted_1() {
		if (savedInner(doubleQuoted_1))
			return reuseInner();
		if (!aheadNot('"'))
			return rejectInner();
		if (!aheadNot('\\'))
			return rejectInner();
		if (!next())
			return rejectInner();
		return acceptInner();
	}

	// =====================================================================
	// singleQuoted = "'" (!"'" !"\" _)* ("\" _ (!"'" !"\" _)*)* "'" ;
	// =====================================================================
	private boolean singleQuoted() {
		if (saved(singleQuoted))
			return reuse();
		if (!next('\''))
			return reject();
		while (singleQuoted_0())
			;
		while (singleQuoted_1())
			;
		if (!next('\''))
			return reject();
		return accept();
	}

	// -------------------------------------------------------------------
	// singleQuoted_0 = !"'" !"\" _
	// -------------------------------------------------------------------
	private boolean singleQuoted_0() {
		if (savedInner(singleQuoted_0))
			return reuseInner();
		if (!aheadNot('\''))
			return rejectInner();
		if (!aheadNot('\\'))
			return rejectInner();
		if (!next())
			return rejectInner();
		return acceptInner();
	}

	// -------------------------------------------------------------------
	// singleQuoted_1 = "\" _ (!"'" !"\" _)*
	// -------------------------------------------------------------------
	private boolean singleQuoted_1() {
		if (savedInner(singleQuoted_1))
			return reuseInner();
		if (!next('\\'))
			return rejectInner();
		if (!next())
			return rejectInner();
		while (singleQuoted_0())
			;
		return acceptInner();
	}

	// =====================================================================
	// regexp = "/" (!"/" !"\" _)* ("\" _ (!"/" !"\" _)*)* "/" ("m" / "g"
	// / "i")* ;
	// =====================================================================
	private boolean regexp() {
		if (saved(regexp))
			return reuse();
		if (!next('/'))
			return reject();
		while (regexp_0())
			;
		while (regexp_1())
			;
		if (!next('/'))
			return reject();
		while (regexp_2())
			;
		return accept();
	}

	// -------------------------------------------------------------------
	// regexp_0 = !"/" !"\" _
	// -------------------------------------------------------------------
	private boolean regexp_0() {
		if (savedInner(regexp_0))
			return reuseInner();
		if (!aheadNot('/'))
			return rejectInner();
		if (!aheadNot('\\'))
			return rejectInner();
		if (!next())
			return rejectInner();
		return acceptInner();
	}

	// -------------------------------------------------------------------
	// regexp_1 = "\" _ (!"/" !"\" _)*
	// -------------------------------------------------------------------
	private boolean regexp_1() {
		if (savedInner(regexp_1))
			return reuseInner();
		if (!next('\\'))
			return rejectInner();
		if (!next())
			return rejectInner();
		while (regexp_0())
			;
		return acceptInner();
	}

	// -------------------------------------------------------------------
	// regexp_2 = "m" / "g" / "i"
	// -------------------------------------------------------------------
	private boolean regexp_2() {
		if (savedInner(regexp_2))
			return reuseInner();
		if (next('m'))
			return acceptInner();
		if (next('g'))
			return acceptInner();
		if (next('i'))
			return acceptInner();
		return rejectInner();
	}

	// =====================================================================
	// multilineComment = "/*" (!"*/" _)* "*/" ;
	// =====================================================================
	private boolean multilineComment() {
		if (saved(multilineComment))
			return reuse();
		if (!next("/*"))
			return reject();
		while (multilineComment_0())
			;
		if (!next("*/"))
			return reject();
		return accept();
	}

	// -------------------------------------------------------------------
	// multilineComment_0 = !"*/" _
	// -------------------------------------------------------------------
	private boolean multilineComment_0() {
		if (savedInner(multilineComment_0))
			return reuseInner();
		if (!aheadNot("*/"))
			return rejectInner();
		if (!next())
			return rejectInner();
		return acceptInner();
	}

	// =====================================================================
	// singlelineComment = "//" (!"\n" !"\r" _)* ("\r" / "\r\n" / "\n") ;
	// =====================================================================
	private boolean singlelineComment() {
		if (saved(singlelineComment))
			return reuse();
		if (!next("//"))
			return reject();
		while (singlelineComment_0())
			;
		if (!next('\r') && !next("\r\n") && !next('\n'))
			return reject();
		return accept();
	}

	// -------------------------------------------------------------------
	// singlelineComment_0 = !"\n" !"\r" _
	// -------------------------------------------------------------------
	private boolean singlelineComment_0() {
		if (savedInner(singlelineComment_0))
			return reuseInner();
		if (!aheadNot('\n'))
			return rejectInner();
		if (!aheadNot('\r'))
			return rejectInner();
		if (!next())
			return rejectInner();
		return acceptInner();
	}

	// =====================================================================
	// spacing = (space / multilineComment / singlelineComment)+ ;
	// =====================================================================
	private boolean spacing() {
		if (saved(spacing))
			return reuse();
		if (!spacing_0())
			return reject();
		while (spacing_0())
			;
		return accept();
	}

	// -------------------------------------------------------------------
	// spacing_0 = space / multilineComment / singlelineComment
	// -------------------------------------------------------------------
	private boolean spacing_0() {
		if (savedInner(spacing_0))
			return reuseInner();
		if (space())
			return acceptInner();
		if (multilineComment())
			return acceptInner();
		if (singlelineComment())
			return acceptInner();
		return rejectInner();
	}

	// =====================================================================
	// space = [ \t\r\n] ;
	// =====================================================================
	private boolean space() {
		if (saved(space))
			return reuse();
		if (!nextIn(" \t\r\n"))
			return reject();
		return accept();
	}

	// =====================================================================
	// NOT = "!" spacing ;
	// =====================================================================
	private boolean NOT() {
		if (saved(NOT))
			return reuse();
		if (!next('!'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// NOTEQ = "!=" spacing ;
	// =====================================================================
	private boolean NOTEQ() {
		if (saved(NOTEQ))
			return reuse();
		if (!next("!="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// SUR = "%" spacing ;
	// =====================================================================
	private boolean SUR() {
		if (saved(SUR))
			return reuse();
		if (!next('%'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// SUREEQ = "%=" spacing ;
	// =====================================================================
	private boolean SUREEQ() {
		if (saved(SUREEQ))
			return reuse();
		if (!next("%="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// AND = "&&" spacing ;
	// =====================================================================
	private boolean AND() {
		if (saved(AND))
			return reuse();
		if (!next("&&"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// BITAND = "&" spacing ;
	// =====================================================================
	private boolean BITAND() {
		if (saved(BITAND))
			return reuse();
		if (!next('&'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// BITANDEQ = "&=" spacing ;
	// =====================================================================
	private boolean BITANDEQ() {
		if (saved(BITANDEQ))
			return reuse();
		if (!next("&="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// LPAR = "(" spacing ;
	// =====================================================================
	private boolean LPAR() {
		if (saved(LPAR))
			return reuse();
		if (!next('('))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// RPAR = ")" spacing ;
	// =====================================================================
	private boolean RPAR() {
		if (saved(RPAR))
			return reuse();
		if (!next(')'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// MUL = "*" spacing ;
	// =====================================================================
	private boolean MUL() {
		if (saved(MUL))
			return reuse();
		if (!next('*'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// MULEQ = "*=" spacing ;
	// =====================================================================
	private boolean MULEQ() {
		if (saved(MULEQ))
			return reuse();
		if (!next("*="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// ADD = "+" spacing ;
	// =====================================================================
	private boolean ADD() {
		if (saved(ADD))
			return reuse();
		if (!next('+'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// INC = "++" spacing ;
	// =====================================================================
	private boolean INC() {
		if (saved(INC))
			return reuse();
		if (!next("++"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// ADDEQ = "+=" spacing ;
	// =====================================================================
	private boolean ADDEQ() {
		if (saved(ADDEQ))
			return reuse();
		if (!next("+="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// COMMA = "," spacing ;
	// =====================================================================
	private boolean COMMA() {
		if (saved(COMMA))
			return reuse();
		if (!next(','))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// SUB = "-" spacing ;
	// =====================================================================
	private boolean SUB() {
		if (saved(SUB))
			return reuse();
		if (!next('-'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// DEC = "--" spacing ;
	// =====================================================================
	private boolean DEC() {
		if (saved(DEC))
			return reuse();
		if (!next("--"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// SUBEQ = "-=" spacing ;
	// =====================================================================
	private boolean SUBEQ() {
		if (saved(SUBEQ))
			return reuse();
		if (!next("-="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// ARROW = "->" spacing ;
	// =====================================================================
	private boolean ARROW() {
		if (saved(ARROW))
			return reuse();
		if (!next("->"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// DOT = "." spacing ;
	// =====================================================================
	private boolean DOT() {
		if (saved(DOT))
			return reuse();
		if (!next('.'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// ARGS = "..." spacing ;
	// =====================================================================
	private boolean ARGS() {
		if (saved(ARGS))
			return reuse();
		if (!next("..."))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// DIV = "/" spacing ;
	// =====================================================================
	private boolean DIV() {
		if (saved(DIV))
			return reuse();
		if (!next('/'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// DIVEQ = "/=" spacing ;
	// =====================================================================
	private boolean DIVEQ() {
		if (saved(DIVEQ))
			return reuse();
		if (!next("/="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// COLON = ":" spacing ;
	// =====================================================================
	private boolean COLON() {
		if (saved(COLON))
			return reuse();
		if (!next(':'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// SEMI = ";" spacing ;
	// =====================================================================
	private boolean SEMI() {
		if (saved(SEMI))
			return reuse();
		if (!next(';'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// LT = "<" spacing ;
	// =====================================================================
	private boolean LT() {
		if (saved(LT))
			return reuse();
		if (!next('<'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// LSHIFT = "<<" spacing ;
	// =====================================================================
	private boolean LSHIFT() {
		if (saved(LSHIFT))
			return reuse();
		if (!next("<<"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// LSHIFTEQ = "<<=" spacing ;
	// =====================================================================
	private boolean LSHIFTEQ() {
		if (saved(LSHIFTEQ))
			return reuse();
		if (!next("<<="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// LTEQ = "<=" spacing ;
	// =====================================================================
	private boolean LTEQ() {
		if (saved(LTEQ))
			return reuse();
		if (!next("<="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// ASSIGN = "=" spacing ;
	// =====================================================================
	private boolean ASSIGN() {
		if (saved(ASSIGN))
			return reuse();
		if (!next('='))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// EQ = "==" spacing ;
	// =====================================================================
	private boolean EQ() {
		if (saved(EQ))
			return reuse();
		if (!next("=="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// GT = ">" spacing ;
	// =====================================================================
	private boolean GT() {
		if (saved(GT))
			return reuse();
		if (!next('>'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// GTEQ = ">=" spacing ;
	// =====================================================================
	private boolean GTEQ() {
		if (saved(GTEQ))
			return reuse();
		if (!next(">="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// COND = "?" spacing ;
	// =====================================================================
	private boolean COND() {
		if (saved(COND))
			return reuse();
		if (!next('?'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// LBRA = "[" spacing ;
	// =====================================================================
	private boolean LBRA() {
		if (saved(LBRA))
			return reuse();
		if (!next('['))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// RBRA = "]" spacing ;
	// =====================================================================
	private boolean RBRA() {
		if (saved(RBRA))
			return reuse();
		if (!next(']'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// XOR = "^" spacing ;
	// =====================================================================
	private boolean XOR() {
		if (saved(XOR))
			return reuse();
		if (!next('^'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// XOREQ = "^=" spacing ;
	// =====================================================================
	private boolean XOREQ() {
		if (saved(XOREQ))
			return reuse();
		if (!next("^="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// LWING = "{" spacing ;
	// =====================================================================
	private boolean LWING() {
		if (saved(LWING))
			return reuse();
		if (!next('{'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// BITOR = "|" spacing ;
	// =====================================================================
	private boolean BITOR() {
		if (saved(BITOR))
			return reuse();
		if (!next('|'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// BITOREQ = "|=" spacing ;
	// =====================================================================
	private boolean BITOREQ() {
		if (saved(BITOREQ))
			return reuse();
		if (!next("|="))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// OR = "||" spacing ;
	// =====================================================================
	private boolean OR() {
		if (saved(OR))
			return reuse();
		if (!next("||"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// RWING = "}" spacing ;
	// =====================================================================
	private boolean RWING() {
		if (saved(RWING))
			return reuse();
		if (!next('}'))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// MAYBEUNDEFINED = "MayBeUndefined" spacing ;
	// =====================================================================
	private boolean MAYBEUNDEFINED() {
		if (saved(MAYBEUNDEFINED))
			return reuse();
		if (!next("MayBeUndefined"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// NULLABLE = "Nullable" spacing ;
	// =====================================================================
	private boolean NULLABLE() {
		if (saved(NULLABLE))
			return reuse();
		if (!next("Nullable"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// ABSTRACT = "abstract" spacing ;
	// =====================================================================
	private boolean ABSTRACT() {
		if (saved(ABSTRACT))
			return reuse();
		if (!next("abstract"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// AS = "as" spacing ;
	// =====================================================================
	private boolean AS() {
		if (saved(AS))
			return reuse();
		if (!next("as"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// ASSERT = "assert" spacing ;
	// =====================================================================
	private boolean ASSERT() {
		if (saved(ASSERT))
			return reuse();
		if (!next("assert"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// BOOLEAN = "boolean" spacing ;
	// =====================================================================
	private boolean BOOLEAN() {
		if (saved(BOOLEAN))
			return reuse();
		if (!next("boolean"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// BREAK = "break" spacing ;
	// =====================================================================
	private boolean BREAK() {
		if (saved(BREAK))
			return reuse();
		if (!next("break"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// CASE = "case" spacing ;
	// =====================================================================
	private boolean CASE() {
		if (saved(CASE))
			return reuse();
		if (!next("case"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// CATCH = "catch" spacing ;
	// =====================================================================
	private boolean CATCH() {
		if (saved(CATCH))
			return reuse();
		if (!next("catch"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// CLASS = "class" spacing ;
	// =====================================================================
	private boolean CLASS() {
		if (saved(CLASS))
			return reuse();
		if (!next("class"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// CONST = "const" spacing ;
	// =====================================================================
	private boolean CONST() {
		if (saved(CONST))
			return reuse();
		if (!next("const"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// CONSTRUCTOR = "constructor" spacing ;
	// =====================================================================
	private boolean CONSTRUCTOR() {
		if (saved(CONSTRUCTOR))
			return reuse();
		if (!next("constructor"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// CONTINUE = "continue" spacing ;
	// =====================================================================
	private boolean CONTINUE() {
		if (saved(CONTINUE))
			return reuse();
		if (!next("continue"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// DEBUGGER = "debugger" spacing ;
	// =====================================================================
	private boolean DEBUGGER() {
		if (saved(DEBUGGER))
			return reuse();
		if (!next("debugger"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// DEFAULT = "default" spacing ;
	// =====================================================================
	private boolean DEFAULT() {
		if (saved(DEFAULT))
			return reuse();
		if (!next("default"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// DELETE = "delete" spacing ;
	// =====================================================================
	private boolean DELETE() {
		if (saved(DELETE))
			return reuse();
		if (!next("delete"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// DO = "do" spacing ;
	// =====================================================================
	private boolean DO() {
		if (saved(DO))
			return reuse();
		if (!next("do"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// ELSE = "else" spacing ;
	// =====================================================================
	private boolean ELSE() {
		if (saved(ELSE))
			return reuse();
		if (!next("else"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// EXTENDS = "extends" spacing ;
	// =====================================================================
	private boolean EXTENDS() {
		if (saved(EXTENDS))
			return reuse();
		if (!next("extends"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// FALSE = "false" spacing ;
	// =====================================================================
	private boolean FALSE() {
		if (saved(FALSE))
			return reuse();
		if (!next("false"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// FINAL = "final" spacing ;
	// =====================================================================
	private boolean FINAL() {
		if (saved(FINAL))
			return reuse();
		if (!next("final"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// FINALLY = "finally" spacing ;
	// =====================================================================
	private boolean FINALLY() {
		if (saved(FINALLY))
			return reuse();
		if (!next("finally"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// FOR = "for" spacing ;
	// =====================================================================
	private boolean FOR() {
		if (saved(FOR))
			return reuse();
		if (!next("for"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// FROM = "from" spacing ;
	// =====================================================================
	private boolean FROM() {
		if (saved(FROM))
			return reuse();
		if (!next("from"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// FUNCTION = "function" spacing ;
	// =====================================================================
	private boolean FUNCTION() {
		if (saved(FUNCTION))
			return reuse();
		if (!next("function"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// IF = "if" spacing ;
	// =====================================================================
	private boolean IF() {
		if (saved(IF))
			return reuse();
		if (!next("if"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// IMPLEMENTS = "implements" spacing ;
	// =====================================================================
	private boolean IMPLEMENTS() {
		if (saved(IMPLEMENTS))
			return reuse();
		if (!next("implements"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// IMPORT = "import" spacing ;
	// =====================================================================
	private boolean IMPORT() {
		if (saved(IMPORT))
			return reuse();
		if (!next("import"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// IN = "in" spacing ;
	// =====================================================================
	private boolean IN() {
		if (saved(IN))
			return reuse();
		if (!next("in"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// INLINE = "inline" spacing ;
	// =====================================================================
	private boolean INLINE() {
		if (saved(INLINE))
			return reuse();
		if (!next("inline"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// INSTANCEOF = "instanceof" spacing ;
	// =====================================================================
	private boolean INSTANCEOF() {
		if (saved(INSTANCEOF))
			return reuse();
		if (!next("instanceof"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// INT = "int" spacing ;
	// =====================================================================
	private boolean INT() {
		if (saved(INT))
			return reuse();
		if (!next("int"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// INTERFACE = "interface" spacing ;
	// =====================================================================
	private boolean INTERFACE() {
		if (saved(INTERFACE))
			return reuse();
		if (!next("interface"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// INTO = "into" spacing ;
	// =====================================================================
	private boolean INTO() {
		if (saved(INTO))
			return reuse();
		if (!next("into"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// LOG = "log" spacing ;
	// =====================================================================
	private boolean LOG() {
		if (saved(LOG))
			return reuse();
		if (!next("log"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// MIXIN = "mixin" spacing ;
	// =====================================================================
	private boolean MIXIN() {
		if (saved(MIXIN))
			return reuse();
		if (!next("mixin"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// NATIVE = "native" spacing ;
	// =====================================================================
	private boolean NATIVE() {
		if (saved(NATIVE))
			return reuse();
		if (!next("native"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// NEW = "new" spacing ;
	// =====================================================================
	private boolean NEW() {
		if (saved(NEW))
			return reuse();
		if (!next("new"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// NULL = "null" spacing ;
	// =====================================================================
	private boolean NULL() {
		if (saved(NULL))
			return reuse();
		if (!next("null"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// NUMBER = "number" spacing ;
	// =====================================================================
	private boolean NUMBER() {
		if (saved(NUMBER))
			return reuse();
		if (!next("number"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// OVERRIDE = "override" spacing ;
	// =====================================================================
	private boolean OVERRIDE() {
		if (saved(OVERRIDE))
			return reuse();
		if (!next("override"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// RETURN = "return" spacing ;
	// =====================================================================
	private boolean RETURN() {
		if (saved(RETURN))
			return reuse();
		if (!next("return"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// STATIC = "static" spacing ;
	// =====================================================================
	private boolean STATIC() {
		if (saved(STATIC))
			return reuse();
		if (!next("static"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// STRING = "string" spacing ;
	// =====================================================================
	private boolean STRING() {
		if (saved(STRING))
			return reuse();
		if (!next("string"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// SUPER = "super" spacing ;
	// =====================================================================
	private boolean SUPER() {
		if (saved(SUPER))
			return reuse();
		if (!next("super"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// SWITCH = "switch" spacing ;
	// =====================================================================
	private boolean SWITCH() {
		if (saved(SWITCH))
			return reuse();
		if (!next("switch"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// THIS = "this" spacing ;
	// =====================================================================
	private boolean THIS() {
		if (saved(THIS))
			return reuse();
		if (!next("this"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// THROW = "throw" spacing ;
	// =====================================================================
	private boolean THROW() {
		if (saved(THROW))
			return reuse();
		if (!next("throw"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// TRUE = "true" spacing ;
	// =====================================================================
	private boolean TRUE() {
		if (saved(TRUE))
			return reuse();
		if (!next("true"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// TRY = "try" spacing ;
	// =====================================================================
	private boolean TRY() {
		if (saved(TRY))
			return reuse();
		if (!next("try"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// TYPEOF = "typeof" spacing ;
	// =====================================================================
	private boolean TYPEOF() {
		if (saved(TYPEOF))
			return reuse();
		if (!next("typeof"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// UNDEFINED = "undefined" spacing ;
	// =====================================================================
	private boolean UNDEFINED() {
		if (saved(UNDEFINED))
			return reuse();
		if (!next("undefined"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// VAR = "var" spacing ;
	// =====================================================================
	private boolean VAR() {
		if (saved(VAR))
			return reuse();
		if (!next("var"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// VARIANT = "variant" spacing ;
	// =====================================================================
	private boolean VARIANT() {
		if (saved(VARIANT))
			return reuse();
		if (!next("variant"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// VOID = "void" spacing ;
	// =====================================================================
	private boolean VOID() {
		if (saved(VOID))
			return reuse();
		if (!next("void"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// WHILE = "while" spacing ;
	// =====================================================================
	private boolean WHILE() {
		if (saved(WHILE))
			return reuse();
		if (!next("while"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// BLTCONFAKE = "__fake__" spacing ;
	// =====================================================================
	private boolean BLTCONFAKE() {
		if (saved(BLTCONFAKE))
			return reuse();
		if (!next("__fake__"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// BLTCONNOCONVERT = "__noconvert__" spacing ;
	// =====================================================================
	private boolean BLTCONNOCONVERT() {
		if (saved(BLTCONNOCONVERT))
			return reuse();
		if (!next("__noconvert__"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// BLTCONPURE = "__pure__" spacing ;
	// =====================================================================
	private boolean BLTCONPURE() {
		if (saved(BLTCONPURE))
			return reuse();
		if (!next("__pure__"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =====================================================================
	// BLTCONREADONLY = "__readonly__" spacing ;
	// =====================================================================
	private boolean BLTCONREADONLY() {
		if (saved(BLTCONREADONLY))
			return reuse();
		if (!next("__readonly__"))
			return reject();
		if (!spacing())
			return reject();
		return accept();
	}

	// =======================================================================
	//
	// Cache objects
	//
	// =======================================================================

	final Cache programFile = new Cache("programFile", "programFile");
	final Cache importStatement = new Cache("importStatement",
			"importStatement");
	final Cache classDefinition = new Cache("classDefinition",
			"classDefinition");
	final Cache oClassModifiers = new Cache("oClassModifiers",
			"oClassModifiers");
	final Cache oClassDef = new Cache("oClassDef", "oClassDef");
	final Cache oInterfaceDef = new Cache("oInterfaceDef", "oInterfaceDef");
	final Cache oMixinDef = new Cache("oMixinDef", "oMixinDef");
	final Cache objectTypeDeclaration = new Cache("objectTypeDeclaration",
			"objectTypeDeclaration");
	final Cache memberDefinition = new Cache("memberDefinition",
			"memberDefinition");
	final Cache IDENT = new Cache("IDENT", "IDENT");
	final Cache formalTypeArguments = new Cache("formalTypeArguments",
			"formalTypeArguments");
	final Cache ident = new Cache("ident", "ident");
	final Cache string = new Cache("string", "string");
	final Cache doubleQuoted = new Cache("doubleQuoted", "doubleQuoted");
	final Cache singleQuoted = new Cache("singleQuoted", "singleQuoted");
	final Cache regexp = new Cache("regexp", "regexp");
	final Cache multilineComment = new Cache("multilineComment",
			"multilineComment");
	final Cache singlelineComment = new Cache("singlelineComment",
			"singlelineComment");
	final Cache spacing = new Cache("spacing", "spacing");
	final Cache space = new Cache("space", "space");
	final Cache NOT = new Cache("NOT", "NOT");
	final Cache NOTEQ = new Cache("NOTEQ", "NOTEQ");
	final Cache SUR = new Cache("SUR", "SUR");
	final Cache SUREEQ = new Cache("SUREEQ", "SUREEQ");
	final Cache AND = new Cache("AND", "AND");
	final Cache BITAND = new Cache("BITAND", "BITAND");
	final Cache BITANDEQ = new Cache("BITANDEQ", "BITANDEQ");
	final Cache LPAR = new Cache("LPAR", "LPAR");
	final Cache RPAR = new Cache("RPAR", "RPAR");
	final Cache MUL = new Cache("MUL", "MUL");
	final Cache MULEQ = new Cache("MULEQ", "MULEQ");
	final Cache ADD = new Cache("ADD", "ADD");
	final Cache INC = new Cache("INC", "INC");
	final Cache ADDEQ = new Cache("ADDEQ", "ADDEQ");
	final Cache COMMA = new Cache("COMMA", "COMMA");
	final Cache SUB = new Cache("SUB", "SUB");
	final Cache DEC = new Cache("DEC", "DEC");
	final Cache SUBEQ = new Cache("SUBEQ", "SUBEQ");
	final Cache ARROW = new Cache("ARROW", "ARROW");
	final Cache DOT = new Cache("DOT", "DOT");
	final Cache ARGS = new Cache("ARGS", "ARGS");
	final Cache DIV = new Cache("DIV", "DIV");
	final Cache DIVEQ = new Cache("DIVEQ", "DIVEQ");
	final Cache COLON = new Cache("COLON", "COLON");
	final Cache SEMI = new Cache("SEMI", "SEMI");
	final Cache LT = new Cache("LT", "LT");
	final Cache LSHIFT = new Cache("LSHIFT", "LSHIFT");
	final Cache LSHIFTEQ = new Cache("LSHIFTEQ", "LSHIFTEQ");
	final Cache LTEQ = new Cache("LTEQ", "LTEQ");
	final Cache ASSIGN = new Cache("ASSIGN", "ASSIGN");
	final Cache EQ = new Cache("EQ", "EQ");
	final Cache GT = new Cache("GT", "GT");
	final Cache GTEQ = new Cache("GTEQ", "GTEQ");
	final Cache COND = new Cache("COND", "COND");
	final Cache LBRA = new Cache("LBRA", "LBRA");
	final Cache RBRA = new Cache("RBRA", "RBRA");
	final Cache XOR = new Cache("XOR", "XOR");
	final Cache XOREQ = new Cache("XOREQ", "XOREQ");
	final Cache LWING = new Cache("LWING", "LWING");
	final Cache BITOR = new Cache("BITOR", "BITOR");
	final Cache BITOREQ = new Cache("BITOREQ", "BITOREQ");
	final Cache OR = new Cache("OR", "OR");
	final Cache RWING = new Cache("RWING", "RWING");
	final Cache MAYBEUNDEFINED = new Cache("MAYBEUNDEFINED", "MAYBEUNDEFINED");
	final Cache NULLABLE = new Cache("NULLABLE", "NULLABLE");
	final Cache ABSTRACT = new Cache("ABSTRACT", "ABSTRACT");
	final Cache AS = new Cache("AS", "AS");
	final Cache ASSERT = new Cache("ASSERT", "ASSERT");
	final Cache BOOLEAN = new Cache("BOOLEAN", "BOOLEAN");
	final Cache BREAK = new Cache("BREAK", "BREAK");
	final Cache CASE = new Cache("CASE", "CASE");
	final Cache CATCH = new Cache("CATCH", "CATCH");
	final Cache CLASS = new Cache("CLASS", "CLASS");
	final Cache CONST = new Cache("CONST", "CONST");
	final Cache CONSTRUCTOR = new Cache("CONSTRUCTOR", "CONSTRUCTOR");
	final Cache CONTINUE = new Cache("CONTINUE", "CONTINUE");
	final Cache DEBUGGER = new Cache("DEBUGGER", "DEBUGGER");
	final Cache DEFAULT = new Cache("DEFAULT", "DEFAULT");
	final Cache DELETE = new Cache("DELETE", "DELETE");
	final Cache DO = new Cache("DO", "DO");
	final Cache ELSE = new Cache("ELSE", "ELSE");
	final Cache EXTENDS = new Cache("EXTENDS", "EXTENDS");
	final Cache FALSE = new Cache("FALSE", "FALSE");
	final Cache FINAL = new Cache("FINAL", "FINAL");
	final Cache FINALLY = new Cache("FINALLY", "FINALLY");
	final Cache FOR = new Cache("FOR", "FOR");
	final Cache FROM = new Cache("FROM", "FROM");
	final Cache FUNCTION = new Cache("FUNCTION", "FUNCTION");
	final Cache IF = new Cache("IF", "IF");
	final Cache IMPLEMENTS = new Cache("IMPLEMENTS", "IMPLEMENTS");
	final Cache IMPORT = new Cache("IMPORT", "IMPORT");
	final Cache IN = new Cache("IN", "IN");
	final Cache INLINE = new Cache("INLINE", "INLINE");
	final Cache INSTANCEOF = new Cache("INSTANCEOF", "INSTANCEOF");
	final Cache INT = new Cache("INT", "INT");
	final Cache INTERFACE = new Cache("INTERFACE", "INTERFACE");
	final Cache INTO = new Cache("INTO", "INTO");
	final Cache LOG = new Cache("LOG", "LOG");
	final Cache MIXIN = new Cache("MIXIN", "MIXIN");
	final Cache NATIVE = new Cache("NATIVE", "NATIVE");
	final Cache NEW = new Cache("NEW", "NEW");
	final Cache NULL = new Cache("NULL", "NULL");
	final Cache NUMBER = new Cache("NUMBER", "NUMBER");
	final Cache OVERRIDE = new Cache("OVERRIDE", "OVERRIDE");
	final Cache RETURN = new Cache("RETURN", "RETURN");
	final Cache STATIC = new Cache("STATIC", "STATIC");
	final Cache STRING = new Cache("STRING", "STRING");
	final Cache SUPER = new Cache("SUPER", "SUPER");
	final Cache SWITCH = new Cache("SWITCH", "SWITCH");
	final Cache THIS = new Cache("THIS", "THIS");
	final Cache THROW = new Cache("THROW", "THROW");
	final Cache TRUE = new Cache("TRUE", "TRUE");
	final Cache TRY = new Cache("TRY", "TRY");
	final Cache TYPEOF = new Cache("TYPEOF", "TYPEOF");
	final Cache UNDEFINED = new Cache("UNDEFINED", "UNDEFINED");
	final Cache VAR = new Cache("VAR", "VAR");
	final Cache VARIANT = new Cache("VARIANT", "VARIANT");
	final Cache VOID = new Cache("VOID", "VOID");
	final Cache WHILE = new Cache("WHILE", "WHILE");
	final Cache BLTCONFAKE = new Cache("BLTCONFAKE", "BLTCONFAKE");
	final Cache BLTCONNOCONVERT = new Cache("BLTCONNOCONVERT",
			"BLTCONNOCONVERT");
	final Cache BLTCONPURE = new Cache("BLTCONPURE", "BLTCONPURE");
	final Cache BLTCONREADONLY = new Cache("BLTCONREADONLY", "BLTCONREADONLY");

	final Cache importStatement_0 = new Cache("importStatement_0"); // ident
																	// (COMMA
																	// ident)*
																	// FROM
	final Cache importStatement_1 = new Cache("importStatement_1"); // INTO
																	// ident
	final Cache importStatement_2 = new Cache("importStatement_2"); // COMMA
																	// ident
	final Cache oClassDef_0 = new Cache("oClassDef_0"); // EXTENDS
														// objectTypeDeclaration
	final Cache oClassDef_1 = new Cache("oClassDef_1"); // IMPLEMENTS
														// objectTypeDeclaration
														// (COMMA
														// objectTypeDeclaration)*
	final Cache oClassDef_2 = new Cache("oClassDef_2"); // COMMA
														// objectTypeDeclaration
	final Cache ident_0 = new Cache("ident_0"); // [a-z] / [A-Z] / "_" / [0-9]
	final Cache doubleQuoted_0 = new Cache("doubleQuoted_0"); // "\" _ (!"""
																// !"\" _)*
	final Cache doubleQuoted_1 = new Cache("doubleQuoted_1"); // !""" !"\" _
	final Cache singleQuoted_0 = new Cache("singleQuoted_0"); // !"'" !"\" _
	final Cache singleQuoted_1 = new Cache("singleQuoted_1"); // "\" _ (!"'"
																// !"\" _)*
	final Cache regexp_0 = new Cache("regexp_0"); // !"/" !"\" _
	final Cache regexp_1 = new Cache("regexp_1"); // "\" _ (!"/" !"\" _)*
	final Cache regexp_2 = new Cache("regexp_2"); // "m" / "g" / "i"
	final Cache multilineComment_0 = new Cache("multilineComment_0"); // !"*/" _
	final Cache singlelineComment_0 = new Cache("singlelineComment_0"); // !"\n"
																		// !"\r"
																		// _
	final Cache spacing_0 = new Cache("spacing_0"); // space / multilineComment
													// / singlelineComment

	// -------------------------------------------------------------------
	// List of Cache objects
	// -------------------------------------------------------------------

	Cache[] cacheList = { programFile, importStatement, classDefinition,
			oClassModifiers, oClassDef, oInterfaceDef, oMixinDef,
			objectTypeDeclaration, memberDefinition, IDENT,
			formalTypeArguments, ident, string, doubleQuoted, singleQuoted,
			regexp, multilineComment, singlelineComment, spacing, space, NOT,
			NOTEQ, SUR, SUREEQ, AND, BITAND, BITANDEQ, LPAR, RPAR, MUL, MULEQ,
			ADD, INC, ADDEQ, COMMA, SUB, DEC, SUBEQ, ARROW, DOT, ARGS, DIV,
			DIVEQ, COLON, SEMI, LT, LSHIFT, LSHIFTEQ, LTEQ, ASSIGN, EQ, GT,
			GTEQ, COND, LBRA, RBRA, XOR, XOREQ, LWING, BITOR, BITOREQ, OR,
			RWING, MAYBEUNDEFINED, NULLABLE, ABSTRACT, AS, ASSERT, BOOLEAN,
			BREAK, CASE, CATCH, CLASS, CONST, CONSTRUCTOR, CONTINUE, DEBUGGER,
			DEFAULT, DELETE, DO, ELSE, EXTENDS, FALSE, FINAL, FINALLY, FOR,
			FROM, FUNCTION, IF, IMPLEMENTS, IMPORT, IN, INLINE, INSTANCEOF,
			INT, INTERFACE, INTO, LOG, MIXIN, NATIVE, NEW, NULL, NUMBER,
			OVERRIDE, RETURN, STATIC, STRING, SUPER, SWITCH, THIS, THROW, TRUE,
			TRY, TYPEOF, UNDEFINED, VAR, VARIANT, VOID, WHILE, BLTCONFAKE,
			BLTCONNOCONVERT, BLTCONPURE, BLTCONREADONLY, importStatement_0,
			importStatement_1, importStatement_2, oClassDef_0, oClassDef_1,
			oClassDef_2, ident_0, doubleQuoted_0, doubleQuoted_1,
			singleQuoted_0, singleQuoted_1, regexp_0, regexp_1, regexp_2,
			multilineComment_0, singlelineComment_0, spacing_0 };
}
